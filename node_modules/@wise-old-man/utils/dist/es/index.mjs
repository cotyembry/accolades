import dayjs from 'dayjs';
import customParseFormatPlugin from 'dayjs/plugin/customParseFormat.js';

var config = {
    defaultUserAgent: `WiseOldMan JS Client v${process.env.npm_package_version}`,
    baseAPIUrl: 'https://api.wiseoldman.net/v2'
};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */


function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

dayjs.extend(customParseFormatPlugin);
function traverseTransform(input, transformation) {
    if (Array.isArray(input)) {
        return input.map(item => traverseTransform(item, transformation));
    }
    if (input !== null && typeof input === 'object') {
        return Object.fromEntries(Object.keys(input).map(key => [key, traverseTransform(input[key], transformation)]));
    }
    return transformation(input);
}
function isValidISODate(input) {
    if (!input || typeof input !== 'string')
        return false;
    // DayJS has a bug with strict parsing with timezones https://github.com/iamkun/dayjs/issues/929
    // So I'll just strip the "Z" timezone
    return input.endsWith('Z') && dayjs(input.slice(0, -1), 'YYYY-MM-DDTHH:mm:ss.SSS', true).isValid();
}
function transformDates(input) {
    return traverseTransform(input, val => (isValidISODate(val) ? new Date(val) : val));
}
function handleError(status, path, data) {
    if (!data)
        return;
    if (status === 400) {
        throw new BadRequestError(path, data.message, data.data);
    }
    if (status === 403) {
        throw new ForbiddenError(path, data.message);
    }
    if (status === 404) {
        throw new NotFoundError(path, data.message);
    }
    if (status === 429) {
        throw new RateLimitError(path, data.message);
    }
    if (status === 500) {
        throw new InternalServerError(path, data.message);
    }
}
class BadRequestError extends Error {
    constructor(resource, message, data) {
        super(message);
        this.name = 'BadRequestError';
        this.resource = resource;
        this.statusCode = 400;
        this.data = data;
    }
}
class ForbiddenError extends Error {
    constructor(resource, message) {
        super(message);
        this.name = 'ForbiddenError';
        this.resource = resource;
        this.statusCode = 403;
    }
}
class NotFoundError extends Error {
    constructor(resource, message) {
        super(message);
        this.name = 'NotFoundError';
        this.resource = resource;
        this.statusCode = 404;
    }
}
class RateLimitError extends Error {
    constructor(resource, message) {
        super(message);
        this.name = 'RateLimitError';
        this.resource = resource;
        this.statusCode = 429;
    }
}
class InternalServerError extends Error {
    constructor(resource, message) {
        super(message);
        this.name = 'InternalServerError';
        this.resource = resource;
        this.statusCode = 500;
    }
}

class BaseAPIClient {
    constructor(headers, baseUrl) {
        this.baseUrl = baseUrl;
        this.headers = Object.assign({ Accept: 'application/json', 'Content-Type': 'application/json' }, headers);
    }
    buildParams(_a) {
        var params = __rest(_a, []);
        const builder = new URLSearchParams();
        Object.keys(params)
            .filter(k => params[k] !== undefined)
            .forEach(k => builder.set(k, params[k]));
        const query = builder.toString();
        return query ? `?${query}` : '';
    }
    fetch({ method, path, body, params }) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = { method, body: undefined, headers: this.headers };
            let query = '';
            if (body) {
                req.body = JSON.stringify(body);
            }
            if (params) {
                query = this.buildParams(params);
            }
            return yield fetch(this.baseUrl + path + query, req);
        });
    }
    request({ method, path, body, params }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.fetch({ method, path, body, params });
            const data = yield res.json();
            if (res.ok) {
                return transformDates(data);
            }
            handleError(res.status, path, data);
        });
    }
    requestText({ method, path, body, params }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.fetch({ method, path, body, params });
            const text = yield res.text();
            if (res.ok) {
                return text;
            }
            handleError(res.status, path, JSON.parse(text));
        });
    }
    postRequest(path, body) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.request({ method: 'POST', path, body: body || {} });
        });
    }
    putRequest(path, body) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.request({ method: 'PUT', path, body: body || {} });
        });
    }
    deleteRequest(path, body) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.request({ method: 'DELETE', path, body: body || {} });
        });
    }
    getRequest(path, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.request({ method: 'GET', path, params });
        });
    }
    getText(path, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestText({ method: 'GET', path, params });
        });
    }
}

class DeltasClient extends BaseAPIClient {
    /**
     * Fetches the current top leaderboard for a specific metric, period, playerType, playerBuild and country.
     * @returns A list of deltas, with their respective players, values and dates included.
     */
    getDeltaLeaderboard(filter) {
        return this.getRequest('/deltas/leaderboard', filter);
    }
}

class GroupsClient extends BaseAPIClient {
    /**
     * Searches for groups that match a partial name.
     * @returns A list of groups.
     */
    searchGroups(name, pagination) {
        return this.getRequest('/groups', Object.assign({ name }, pagination));
    }
    /**
     * Fetches a group's details, including a list of membership objects.
     * @returns A group details object.
     */
    getGroupDetails(id) {
        return this.getRequest(`/groups/${id}`);
    }
    /**
     * Creates a new group.
     * @returns The newly created group, and the verification code that authorizes future changes to it.
     */
    createGroup(payload) {
        return this.postRequest('/groups', payload);
    }
    /**
     * Edits an existing group.
     * @returns The updated group.
     */
    editGroup(id, payload, verificationCode) {
        return this.putRequest(`/groups/${id}`, Object.assign(Object.assign({}, payload), { verificationCode }));
    }
    /**
     * Deletes an existing group.
     * @returns A confirmation message.
     */
    deleteGroup(id, verificationCode) {
        return this.deleteRequest(`/groups/${id}`, { verificationCode });
    }
    /**
     * Adds all (valid) given usernames (and roles) to a group, ignoring duplicates.
     * @returns The number of members added and a confirmation message.
     */
    addMembers(id, members, verificationCode) {
        return this.postRequest(`/groups/${id}/members`, {
            verificationCode,
            members
        });
    }
    /**
     * Remove all given usernames from a group, ignoring usernames that aren't members.
     * @returns The number of members removed and a confirmation message.
     */
    removeMembers(id, usernames, verificationCode) {
        return this.deleteRequest(`/groups/${id}/members`, {
            verificationCode,
            members: usernames
        });
    }
    /**
     * Changes a player's role in a given group.
     * @returns The updated membership, with player included.
     */
    changeRole(id, payload, verificationCode) {
        return this.putRequest(`/groups/${id}/role`, Object.assign(Object.assign({}, payload), { verificationCode }));
    }
    /**
     * Adds an "update" request to the queue, for each outdated group member.
     * @returns The number of players to be updated and a confirmation message.
     */
    updateAll(id, verificationCode) {
        return this.postRequest(`/groups/${id}/update-all`, {
            verificationCode
        });
    }
    /**
     * Fetches all of the groups's competitions
     * @returns A list of competitions.
     */
    getGroupCompetitions(id, pagination) {
        return this.getRequest(`/groups/${id}/competitions`, Object.assign({}, pagination));
    }
    getGroupGains(id, filter, pagination) {
        return this.getRequest(`/groups/${id}/gained`, Object.assign(Object.assign({}, pagination), filter));
    }
    /**
     * Fetches a group members' latest achievements.
     * @returns A list of achievements.
     */
    getGroupAchievements(id, pagination) {
        return this.getRequest(`/groups/${id}/achievements`, Object.assign({}, pagination));
    }
    /**
     * Fetches a group's record leaderboard for a specific metric and period.
     * @returns A list of records, including their respective players.
     */
    getGroupRecords(id, filter, pagination) {
        return this.getRequest(`/groups/${id}/records`, Object.assign(Object.assign({}, pagination), filter));
    }
    /**
     * Fetches a group's hiscores for a specific metric.
     * @returns A list of hiscores entries (value, rank), including their respective players.
     */
    getGroupHiscores(id, metric, pagination) {
        return this.getRequest(`/groups/${id}/hiscores`, Object.assign(Object.assign({}, pagination), { metric }));
    }
    /**
     * Fetches a group members' latest name changes.
     * @returns A list of name change (approved) requests.
     */
    getGroupNameChanges(id, pagination) {
        return this.getRequest(`/groups/${id}/name-changes`, Object.assign({}, pagination));
    }
    /**
     * Fetches a group's general statistics.
     * @returns An object with a few statistic values and an average stats snapshot.
     */
    getGroupStatistics(id) {
        return this.getRequest(`/groups/${id}/statistics`);
    }
    /**
     * Fetches a group's activity.
     * @returns A list of a group's (join, leave and role changed) activity.
     */
    getGroupActivity(id, pagination) {
        return this.getRequest(`/groups/${id}/activity`, Object.assign({}, pagination));
    }
    /**
     * Fetches the groups's member list in CSV format.
     * @returns A string containing the CSV content.
     */
    getMembersCSV(id) {
        return this.getText(`/groups/${id}/csv`);
    }
}

class PlayersClient extends BaseAPIClient {
    /**
     * Searches players by partial username.
     * @returns A list of players.
     */
    searchPlayers(partialUsername, pagination) {
        return this.getRequest('/players/search', Object.assign({ username: partialUsername }, pagination));
    }
    /**
     * Updates/tracks a player.
     * @returns The player's new details, including the latest snapshot.
     */
    updatePlayer(username) {
        return this.postRequest(`/players/${username}`);
    }
    /**
     * Asserts (and attempts to fix, if necessary) a player's game-mode type.
     * @returns The updated player, and an indication of whether the type was changed.
     */
    assertPlayerType(username) {
        return this.postRequest(`/players/${username}/assert-type`);
    }
    /**
     * Fetches a player's details.
     * @returns The player's details, including the latest snapshot.
     */
    getPlayerDetails(username) {
        return this.getRequest(`/players/${username}`);
    }
    /**
     * Fetches a player's details by ID.
     * @returns The player's details, including the latest snapshot.
     */
    getPlayerDetailsById(id) {
        return this.getRequest(`/players/id/${id}`);
    }
    /**
     * Fetches a player's current achievements.
     * @returns A list of achievements.
     */
    getPlayerAchievements(username) {
        return this.getRequest(`/players/${username}/achievements`);
    }
    /**
     * Fetches a player's current achievement progress.
     * @returns A list of achievements (completed or otherwise), with their respective relative/absolute progress percentage.
     */
    getPlayerAchievementProgress(username) {
        return this.getRequest(`/players/${username}/achievements/progress`);
    }
    /**
     * Fetches all of the player's competition participations.
     * @returns A list of participations, with the respective competition included.
     */
    getPlayerCompetitions(username, filter, pagination) {
        return this.getRequest(`/players/${username}/competitions`, Object.assign(Object.assign({}, filter), pagination));
    }
    /**
     * Fetches all of the player's competition participations' standings.
     * @returns A list of participations, with the respective competition, rank and progress included.
     */
    getPlayerCompetitionStandings(username, filter) {
        return this.getRequest(`/players/${username}/competitions/standings`, filter);
    }
    /**
     * Fetches all of the player's group memberships.
     * @returns A list of memberships, with the respective group included.
     */
    getPlayerGroups(username, pagination) {
        return this.getRequest(`/players/${username}/groups`, pagination);
    }
    /**
     * Fetches a player's gains, for a specific period or time range, as a [metric: data] map.
     * @returns A map of each metric's gained data.
     */
    getPlayerGains(username, options) {
        return this.getRequest(`/players/${username}/gained`, options);
    }
    /**
     * Fetches all of the player's records.
     * @returns A list of records.
     */
    getPlayerRecords(username, options) {
        return this.getRequest(`/players/${username}/records`, options);
    }
    /**
     * Fetches all of the player's past snapshots.
     * @returns A list of snapshots.
     */
    getPlayerSnapshots(username, filter, pagination) {
        return this.getRequest(`/players/${username}/snapshots`, Object.assign(Object.assign({}, filter), pagination));
    }
    /**
     * Fetches all of the player's past snapshots' timeline.
     * @returns A list of timeseries data (value, rank, date)
     */
    getPlayerSnapshotTimeline(username, metric, options) {
        return this.getRequest(`/players/${username}/snapshots/timeline`, Object.assign(Object.assign({}, options), { metric }));
    }
    /**
     * Fetches all of the player's approved name changes.
     * @returns A list of name changes.
     */
    getPlayerNames(username) {
        return this.getRequest(`/players/${username}/names`);
    }
    /**
     * Fetches all of archived players that previously held this username.
     * @returns A list of player archives.
     */
    getPlayerArchives(username) {
        return this.getRequest(`/players/${username}/archives`);
    }
}

class RecordsClient extends BaseAPIClient {
    /**
     * Fetches the current records leaderboard for a specific metric, period, playerType, playerBuild and country.
     * @returns A list of records, with their respective players, dates and values included.
     */
    getRecordLeaderboard(filter) {
        return this.getRequest('/records/leaderboard', filter);
    }
}

/**
 * Prisma currently seems to ignore the @map() in enum declarations.
 *
 * So by declaring this enum in the schema file:
 *
 * enum NameChangeStatus {
 *    PENDING     @map('pending')
 *    DENIED      @map('denied')
 *    APPROVED    @map('approved')
 * }
 *
 * you would expect the prisma client to then generate the following object:
 *
 * const NameChangeStatus = {
 *    PENDING: 'pending',
 *    DENIED: 'denied',
 *    APPROVED: 'approved',
 * }
 *
 * but unfortunately, the mapping is only used for queries, and the actual esulting object is this:
 *
 * const NameChangeStatus = {
 *    PENDING: 'PENDING',
 *    DENIED: 'DENIED',
 *    APPROVED: 'APPROVED',
 * }
 *
 * And because I'd hate having to call enum values in lowercase, like:
 *    NameChangeStatus.pending
 *    Metric.king_black_dragon
 *    Period.day
 *
 * I'd rather do some mapping to ensure I have the best of both worlds,
 * lowercase database values, but with uppercase in code.
 * With the mappings below, we can now use prisma enums by calling them with uppercase, like:
 *
 *    NameChangeStatus.PENDING
 *    Metric.KING_BLACK_DRAGON
 *    Period.DAY
 *
 */
const Skill = {
    OVERALL: 'overall',
    ATTACK: 'attack',
    DEFENCE: 'defence',
    STRENGTH: 'strength',
    HITPOINTS: 'hitpoints',
    RANGED: 'ranged',
    PRAYER: 'prayer',
    MAGIC: 'magic',
    COOKING: 'cooking',
    WOODCUTTING: 'woodcutting',
    FLETCHING: 'fletching',
    FISHING: 'fishing',
    FIREMAKING: 'firemaking',
    CRAFTING: 'crafting',
    SMITHING: 'smithing',
    MINING: 'mining',
    HERBLORE: 'herblore',
    AGILITY: 'agility',
    THIEVING: 'thieving',
    SLAYER: 'slayer',
    FARMING: 'farming',
    RUNECRAFTING: 'runecrafting',
    HUNTER: 'hunter',
    CONSTRUCTION: 'construction'
};
const Activity = {
    LEAGUE_POINTS: 'league_points',
    BOUNTY_HUNTER_HUNTER: 'bounty_hunter_hunter',
    BOUNTY_HUNTER_ROGUE: 'bounty_hunter_rogue',
    CLUE_SCROLLS_ALL: 'clue_scrolls_all',
    CLUE_SCROLLS_BEGINNER: 'clue_scrolls_beginner',
    CLUE_SCROLLS_EASY: 'clue_scrolls_easy',
    CLUE_SCROLLS_MEDIUM: 'clue_scrolls_medium',
    CLUE_SCROLLS_HARD: 'clue_scrolls_hard',
    CLUE_SCROLLS_ELITE: 'clue_scrolls_elite',
    CLUE_SCROLLS_MASTER: 'clue_scrolls_master',
    LAST_MAN_STANDING: 'last_man_standing',
    PVP_ARENA: 'pvp_arena',
    SOUL_WARS_ZEAL: 'soul_wars_zeal',
    GUARDIANS_OF_THE_RIFT: 'guardians_of_the_rift',
    COLOSSEUM_GLORY: 'colosseum_glory'
};
const Boss = {
    ABYSSAL_SIRE: 'abyssal_sire',
    ALCHEMICAL_HYDRA: 'alchemical_hydra',
    AMOXLIATL: 'amoxliatl',
    ARAXXOR: 'araxxor',
    ARTIO: 'artio',
    BARROWS_CHESTS: 'barrows_chests',
    BRYOPHYTA: 'bryophyta',
    CALLISTO: 'callisto',
    CALVARION: 'calvarion',
    CERBERUS: 'cerberus',
    CHAMBERS_OF_XERIC: 'chambers_of_xeric',
    CHAMBERS_OF_XERIC_CM: 'chambers_of_xeric_challenge_mode',
    CHAOS_ELEMENTAL: 'chaos_elemental',
    CHAOS_FANATIC: 'chaos_fanatic',
    COMMANDER_ZILYANA: 'commander_zilyana',
    CORPOREAL_BEAST: 'corporeal_beast',
    CRAZY_ARCHAEOLOGIST: 'crazy_archaeologist',
    DAGANNOTH_PRIME: 'dagannoth_prime',
    DAGANNOTH_REX: 'dagannoth_rex',
    DAGANNOTH_SUPREME: 'dagannoth_supreme',
    DERANGED_ARCHAEOLOGIST: 'deranged_archaeologist',
    DUKE_SUCELLUS: 'duke_sucellus',
    GENERAL_GRAARDOR: 'general_graardor',
    GIANT_MOLE: 'giant_mole',
    GROTESQUE_GUARDIANS: 'grotesque_guardians',
    HESPORI: 'hespori',
    KALPHITE_QUEEN: 'kalphite_queen',
    KING_BLACK_DRAGON: 'king_black_dragon',
    KRAKEN: 'kraken',
    KREEARRA: 'kreearra',
    KRIL_TSUTSAROTH: 'kril_tsutsaroth',
    LUNAR_CHESTS: 'lunar_chests',
    MIMIC: 'mimic',
    NEX: 'nex',
    NIGHTMARE: 'nightmare',
    PHOSANIS_NIGHTMARE: 'phosanis_nightmare',
    OBOR: 'obor',
    PHANTOM_MUSPAH: 'phantom_muspah',
    SARACHNIS: 'sarachnis',
    SCORPIA: 'scorpia',
    SCURRIUS: 'scurrius',
    SKOTIZO: 'skotizo',
    SOL_HEREDIT: 'sol_heredit',
    SPINDEL: 'spindel',
    TEMPOROSS: 'tempoross',
    THE_GAUNTLET: 'the_gauntlet',
    THE_CORRUPTED_GAUNTLET: 'the_corrupted_gauntlet',
    THE_HUEYCOATL: 'the_hueycoatl',
    THE_LEVIATHAN: 'the_leviathan',
    THE_WHISPERER: 'the_whisperer',
    THEATRE_OF_BLOOD: 'theatre_of_blood',
    THEATRE_OF_BLOOD_HARD_MODE: 'theatre_of_blood_hard_mode',
    THERMONUCLEAR_SMOKE_DEVIL: 'thermonuclear_smoke_devil',
    TOMBS_OF_AMASCUT: 'tombs_of_amascut',
    TOMBS_OF_AMASCUT_EXPERT: 'tombs_of_amascut_expert',
    TZKAL_ZUK: 'tzkal_zuk',
    TZTOK_JAD: 'tztok_jad',
    VARDORVIS: 'vardorvis',
    VENENATIS: 'venenatis',
    VETION: 'vetion',
    VORKATH: 'vorkath',
    WINTERTODT: 'wintertodt',
    ZALCANO: 'zalcano',
    ZULRAH: 'zulrah'
};
const ComputedMetric = {
    EHP: 'ehp',
    EHB: 'ehb'
};
const Metric = Object.assign(Object.assign(Object.assign(Object.assign({}, Skill), Activity), Boss), ComputedMetric);
const NameChangeStatus = {
    PENDING: 'pending',
    DENIED: 'denied',
    APPROVED: 'approved'
};
const Period = {
    FIVE_MIN: 'five_min',
    DAY: 'day',
    WEEK: 'week',
    MONTH: 'month',
    YEAR: 'year'
};
const PlayerType = {
    UNKNOWN: 'unknown',
    REGULAR: 'regular',
    IRONMAN: 'ironman',
    HARDCORE: 'hardcore',
    ULTIMATE: 'ultimate'
};
const PlayerBuild = {
    MAIN: 'main',
    F2P: 'f2p',
    F2P_LVL3: 'f2p_lvl3',
    LVL3: 'lvl3',
    ZERKER: 'zerker',
    DEF1: 'def1',
    HP10: 'hp10'
};
const PlayerStatus = {
    ACTIVE: 'active',
    UNRANKED: 'unranked',
    FLAGGED: 'flagged',
    ARCHIVED: 'archived',
    BANNED: 'banned'
};
const CompetitionType = {
    CLASSIC: 'classic',
    TEAM: 'team'
};
const GroupRole = {
    ACHIEVER: 'achiever',
    ADAMANT: 'adamant',
    ADEPT: 'adept',
    ADMINISTRATOR: 'administrator',
    ADMIRAL: 'admiral',
    ADVENTURER: 'adventurer',
    AIR: 'air',
    ANCHOR: 'anchor',
    APOTHECARY: 'apothecary',
    ARCHER: 'archer',
    ARMADYLEAN: 'armadylean',
    ARTILLERY: 'artillery',
    ARTISAN: 'artisan',
    ASGARNIAN: 'asgarnian',
    ASSASSIN: 'assassin',
    ASSISTANT: 'assistant',
    ASTRAL: 'astral',
    ATHLETE: 'athlete',
    ATTACKER: 'attacker',
    BANDIT: 'bandit',
    BANDOSIAN: 'bandosian',
    BARBARIAN: 'barbarian',
    BATTLEMAGE: 'battlemage',
    BEAST: 'beast',
    BERSERKER: 'berserker',
    BLISTERWOOD: 'blisterwood',
    BLOOD: 'blood',
    BLUE: 'blue',
    BOB: 'bob',
    BODY: 'body',
    BRASSICAN: 'brassican',
    BRAWLER: 'brawler',
    BRIGADIER: 'brigadier',
    BRIGAND: 'brigand',
    BRONZE: 'bronze',
    BRUISER: 'bruiser',
    BULWARK: 'bulwark',
    BURGLAR: 'burglar',
    BURNT: 'burnt',
    CADET: 'cadet',
    CAPTAIN: 'captain',
    CARRY: 'carry',
    CHAMPION: 'champion',
    CHAOS: 'chaos',
    CLERIC: 'cleric',
    COLLECTOR: 'collector',
    COLONEL: 'colonel',
    COMMANDER: 'commander',
    COMPETITOR: 'competitor',
    COMPLETIONIST: 'completionist',
    CONSTRUCTOR: 'constructor',
    COOK: 'cook',
    COORDINATOR: 'coordinator',
    CORPORAL: 'corporal',
    COSMIC: 'cosmic',
    COUNCILLOR: 'councillor',
    CRAFTER: 'crafter',
    CREW: 'crew',
    CRUSADER: 'crusader',
    CUTPURSE: 'cutpurse',
    DEATH: 'death',
    DEFENDER: 'defender',
    DEFILER: 'defiler',
    DEPUTY_OWNER: 'deputy_owner',
    DESTROYER: 'destroyer',
    DIAMOND: 'diamond',
    DISEASED: 'diseased',
    DOCTOR: 'doctor',
    DOGSBODY: 'dogsbody',
    DRAGON: 'dragon',
    DRAGONSTONE: 'dragonstone',
    DRUID: 'druid',
    DUELLIST: 'duellist',
    EARTH: 'earth',
    ELITE: 'elite',
    EMERALD: 'emerald',
    ENFORCER: 'enforcer',
    EPIC: 'epic',
    EXECUTIVE: 'executive',
    EXPERT: 'expert',
    EXPLORER: 'explorer',
    FARMER: 'farmer',
    FEEDER: 'feeder',
    FIGHTER: 'fighter',
    FIRE: 'fire',
    FIREMAKER: 'firemaker',
    FIRESTARTER: 'firestarter',
    FISHER: 'fisher',
    FLETCHER: 'fletcher',
    FORAGER: 'forager',
    FREMENNIK: 'fremennik',
    GAMER: 'gamer',
    GATHERER: 'gatherer',
    GENERAL: 'general',
    GNOME_CHILD: 'gnome_child',
    GNOME_ELDER: 'gnome_elder',
    GOBLIN: 'goblin',
    GOLD: 'gold',
    GOON: 'goon',
    GREEN: 'green',
    GREY: 'grey',
    GUARDIAN: 'guardian',
    GUTHIXIAN: 'guthixian',
    HARPOON: 'harpoon',
    HEALER: 'healer',
    HELLCAT: 'hellcat',
    HELPER: 'helper',
    HERBOLOGIST: 'herbologist',
    HERO: 'hero',
    HOLY: 'holy',
    HOARDER: 'hoarder',
    HUNTER: 'hunter',
    IGNITOR: 'ignitor',
    ILLUSIONIST: 'illusionist',
    IMP: 'imp',
    INFANTRY: 'infantry',
    INQUISITOR: 'inquisitor',
    IRON: 'iron',
    JADE: 'jade',
    JUSTICIAR: 'justiciar',
    KANDARIN: 'kandarin',
    KARAMJAN: 'karamjan',
    KHARIDIAN: 'kharidian',
    KITTEN: 'kitten',
    KNIGHT: 'knight',
    LABOURER: 'labourer',
    LAW: 'law',
    LEADER: 'leader',
    LEARNER: 'learner',
    LEGACY: 'legacy',
    LEGEND: 'legend',
    LEGIONNAIRE: 'legionnaire',
    LIEUTENANT: 'lieutenant',
    LOOTER: 'looter',
    LUMBERJACK: 'lumberjack',
    MAGIC: 'magic',
    MAGICIAN: 'magician',
    MAJOR: 'major',
    MAPLE: 'maple',
    MARSHAL: 'marshal',
    MASTER: 'master',
    MAXED: 'maxed',
    MEDIATOR: 'mediator',
    MEDIC: 'medic',
    MENTOR: 'mentor',
    MEMBER: 'member',
    MERCHANT: 'merchant',
    MIND: 'mind',
    MINER: 'miner',
    MINION: 'minion',
    MISTHALINIAN: 'misthalinian',
    MITHRIL: 'mithril',
    MODERATOR: 'moderator',
    MONARCH: 'monarch',
    MORYTANIAN: 'morytanian',
    MYSTIC: 'mystic',
    MYTH: 'myth',
    NATURAL: 'natural',
    NATURE: 'nature',
    NECROMANCER: 'necromancer',
    NINJA: 'ninja',
    NOBLE: 'noble',
    NOVICE: 'novice',
    NURSE: 'nurse',
    OAK: 'oak',
    OFFICER: 'officer',
    ONYX: 'onyx',
    OPAL: 'opal',
    ORACLE: 'oracle',
    ORANGE: 'orange',
    OWNER: 'owner',
    PAGE: 'page',
    PALADIN: 'paladin',
    PAWN: 'pawn',
    PILGRIM: 'pilgrim',
    PINE: 'pine',
    PINK: 'pink',
    PREFECT: 'prefect',
    PRIEST: 'priest',
    PRIVATE: 'private',
    PRODIGY: 'prodigy',
    PROSELYTE: 'proselyte',
    PROSPECTOR: 'prospector',
    PROTECTOR: 'protector',
    PURE: 'pure',
    PURPLE: 'purple',
    PYROMANCER: 'pyromancer',
    QUESTER: 'quester',
    RACER: 'racer',
    RAIDER: 'raider',
    RANGER: 'ranger',
    RECORD_CHASER: 'record_chaser',
    RECRUIT: 'recruit',
    RECRUITER: 'recruiter',
    RED_TOPAZ: 'red_topaz',
    RED: 'red',
    ROGUE: 'rogue',
    RUBY: 'ruby',
    RUNE: 'rune',
    RUNECRAFTER: 'runecrafter',
    SAGE: 'sage',
    SAPPHIRE: 'sapphire',
    SARADOMINIST: 'saradominist',
    SAVIOUR: 'saviour',
    SCAVENGER: 'scavenger',
    SCHOLAR: 'scholar',
    SCOURGE: 'scourge',
    SCOUT: 'scout',
    SCRIBE: 'scribe',
    SEER: 'seer',
    SENATOR: 'senator',
    SENTRY: 'sentry',
    SERENIST: 'serenist',
    SERGEANT: 'sergeant',
    SHAMAN: 'shaman',
    SHERIFF: 'sheriff',
    SHORT_GREEN_GUY: 'short_green_guy',
    SKILLER: 'skiller',
    SKULLED: 'skulled',
    SLAYER: 'slayer',
    SMITER: 'smiter',
    SMITH: 'smith',
    SMUGGLER: 'smuggler',
    SNIPER: 'sniper',
    SOUL: 'soul',
    SPECIALIST: 'specialist',
    SPEED_RUNNER: 'speed_runner',
    SPELLCASTER: 'spellcaster',
    SQUIRE: 'squire',
    STAFF: 'staff',
    STEEL: 'steel',
    STRIDER: 'strider',
    STRIKER: 'striker',
    SUMMONER: 'summoner',
    SUPERIOR: 'superior',
    SUPERVISOR: 'supervisor',
    TEACHER: 'teacher',
    TEMPLAR: 'templar',
    THERAPIST: 'therapist',
    THIEF: 'thief',
    TIRANNIAN: 'tirannian',
    TRIALIST: 'trialist',
    TRICKSTER: 'trickster',
    TZKAL: 'tzkal',
    TZTOK: 'tztok',
    UNHOLY: 'unholy',
    VAGRANT: 'vagrant',
    VANGUARD: 'vanguard',
    WALKER: 'walker',
    WANDERER: 'wanderer',
    WARDEN: 'warden',
    WARLOCK: 'warlock',
    WARRIOR: 'warrior',
    WATER: 'water',
    WILD: 'wild',
    WILLOW: 'willow',
    WILY: 'wily',
    WINTUMBER: 'wintumber',
    WITCH: 'witch',
    WIZARD: 'wizard',
    WORKER: 'worker',
    WRATH: 'wrath',
    XERICIAN: 'xerician',
    YELLOW: 'yellow',
    YEW: 'yew',
    ZAMORAKIAN: 'zamorakian',
    ZAROSIAN: 'zarosian',
    ZEALOT: 'zealot',
    ZENYTE: 'zenyte'
};
const Country = {
    AD: 'AD',
    AE: 'AE',
    AF: 'AF',
    AG: 'AG',
    AI: 'AI',
    AL: 'AL',
    AM: 'AM',
    AO: 'AO',
    AQ: 'AQ',
    AR: 'AR',
    AS: 'AS',
    AT: 'AT',
    AU: 'AU',
    AW: 'AW',
    AX: 'AX',
    AZ: 'AZ',
    BA: 'BA',
    BB: 'BB',
    BD: 'BD',
    BE: 'BE',
    BF: 'BF',
    BG: 'BG',
    BH: 'BH',
    BI: 'BI',
    BJ: 'BJ',
    BL: 'BL',
    BM: 'BM',
    BN: 'BN',
    BO: 'BO',
    BQ: 'BQ',
    BR: 'BR',
    BS: 'BS',
    BT: 'BT',
    BV: 'BV',
    BW: 'BW',
    BY: 'BY',
    BZ: 'BZ',
    CA: 'CA',
    CC: 'CC',
    CD: 'CD',
    CF: 'CF',
    CG: 'CG',
    CH: 'CH',
    CI: 'CI',
    CK: 'CK',
    CL: 'CL',
    CM: 'CM',
    CN: 'CN',
    CO: 'CO',
    CR: 'CR',
    CU: 'CU',
    CV: 'CV',
    CW: 'CW',
    CX: 'CX',
    CY: 'CY',
    CZ: 'CZ',
    DE: 'DE',
    DJ: 'DJ',
    DK: 'DK',
    DM: 'DM',
    DO: 'DO',
    DZ: 'DZ',
    EC: 'EC',
    EE: 'EE',
    EG: 'EG',
    EH: 'EH',
    ER: 'ER',
    ES: 'ES',
    ET: 'ET',
    FI: 'FI',
    FJ: 'FJ',
    FK: 'FK',
    FM: 'FM',
    FO: 'FO',
    FR: 'FR',
    GA: 'GA',
    GB: 'GB',
    GB_NIR: 'GB_NIR',
    GB_SCT: 'GB_SCT',
    GB_WLS: 'GB_WLS',
    GD: 'GD',
    GE: 'GE',
    GF: 'GF',
    GG: 'GG',
    GH: 'GH',
    GI: 'GI',
    GL: 'GL',
    GM: 'GM',
    GN: 'GN',
    GP: 'GP',
    GQ: 'GQ',
    GR: 'GR',
    GS: 'GS',
    GT: 'GT',
    GU: 'GU',
    GW: 'GW',
    GY: 'GY',
    HK: 'HK',
    HM: 'HM',
    HN: 'HN',
    HR: 'HR',
    HT: 'HT',
    HU: 'HU',
    ID: 'ID',
    IE: 'IE',
    IL: 'IL',
    IM: 'IM',
    IN: 'IN',
    IO: 'IO',
    IQ: 'IQ',
    IR: 'IR',
    IS: 'IS',
    IT: 'IT',
    JE: 'JE',
    JM: 'JM',
    JO: 'JO',
    JP: 'JP',
    KE: 'KE',
    KG: 'KG',
    KH: 'KH',
    KI: 'KI',
    KM: 'KM',
    KN: 'KN',
    KP: 'KP',
    KR: 'KR',
    KW: 'KW',
    KY: 'KY',
    KZ: 'KZ',
    LA: 'LA',
    LB: 'LB',
    LC: 'LC',
    LI: 'LI',
    LK: 'LK',
    LR: 'LR',
    LS: 'LS',
    LT: 'LT',
    LU: 'LU',
    LV: 'LV',
    LY: 'LY',
    MA: 'MA',
    MC: 'MC',
    MD: 'MD',
    ME: 'ME',
    MF: 'MF',
    MG: 'MG',
    MH: 'MH',
    MK: 'MK',
    ML: 'ML',
    MM: 'MM',
    MN: 'MN',
    MO: 'MO',
    MP: 'MP',
    MQ: 'MQ',
    MR: 'MR',
    MS: 'MS',
    MT: 'MT',
    MU: 'MU',
    MV: 'MV',
    MW: 'MW',
    MX: 'MX',
    MY: 'MY',
    MZ: 'MZ',
    NA: 'NA',
    NC: 'NC',
    NE: 'NE',
    NF: 'NF',
    NG: 'NG',
    NI: 'NI',
    NL: 'NL',
    NO: 'NO',
    NP: 'NP',
    NR: 'NR',
    NU: 'NU',
    NZ: 'NZ',
    OM: 'OM',
    PA: 'PA',
    PE: 'PE',
    PF: 'PF',
    PG: 'PG',
    PH: 'PH',
    PK: 'PK',
    PL: 'PL',
    PM: 'PM',
    PN: 'PN',
    PR: 'PR',
    PS: 'PS',
    PT: 'PT',
    PW: 'PW',
    PY: 'PY',
    QA: 'QA',
    RE: 'RE',
    RO: 'RO',
    RS: 'RS',
    RU: 'RU',
    RW: 'RW',
    SA: 'SA',
    SB: 'SB',
    SC: 'SC',
    SD: 'SD',
    SE: 'SE',
    SG: 'SG',
    SH: 'SH',
    SI: 'SI',
    SJ: 'SJ',
    SK: 'SK',
    SL: 'SL',
    SM: 'SM',
    SN: 'SN',
    SO: 'SO',
    SR: 'SR',
    SS: 'SS',
    ST: 'ST',
    SV: 'SV',
    SX: 'SX',
    SY: 'SY',
    SZ: 'SZ',
    TC: 'TC',
    TD: 'TD',
    TF: 'TF',
    TG: 'TG',
    TH: 'TH',
    TJ: 'TJ',
    TK: 'TK',
    TL: 'TL',
    TM: 'TM',
    TN: 'TN',
    TO: 'TO',
    TR: 'TR',
    TT: 'TT',
    TV: 'TV',
    TW: 'TW',
    TZ: 'TZ',
    UA: 'UA',
    UG: 'UG',
    UM: 'UM',
    US: 'US',
    UY: 'UY',
    UZ: 'UZ',
    VA: 'VA',
    VC: 'VC',
    VE: 'VE',
    VG: 'VG',
    VI: 'VI',
    VN: 'VN',
    VU: 'VU',
    WF: 'WF',
    WS: 'WS',
    YE: 'YE',
    YT: 'YT',
    ZA: 'ZA',
    ZM: 'ZM',
    ZW: 'ZW'
};
const ActivityType = {
    JOINED: 'joined',
    LEFT: 'left',
    CHANGED_ROLE: 'changed_role'
};

var CompetitionStatus;
(function (CompetitionStatus) {
    CompetitionStatus["UPCOMING"] = "upcoming";
    CompetitionStatus["ONGOING"] = "ongoing";
    CompetitionStatus["FINISHED"] = "finished";
})(CompetitionStatus || (CompetitionStatus = {}));
var CompetitionCSVTableType;
(function (CompetitionCSVTableType) {
    CompetitionCSVTableType["TEAM"] = "team";
    CompetitionCSVTableType["TEAMS"] = "teams";
    CompetitionCSVTableType["PARTICIPANTS"] = "participants";
})(CompetitionCSVTableType || (CompetitionCSVTableType = {}));
const CompetitionTypeProps = {
    [CompetitionType.CLASSIC]: { name: 'Classic' },
    [CompetitionType.TEAM]: { name: 'Team' }
};
const CompetitionStatusProps = {
    [CompetitionStatus.UPCOMING]: { name: 'Upcoming' },
    [CompetitionStatus.ONGOING]: { name: 'Ongoing' },
    [CompetitionStatus.FINISHED]: { name: 'Finished' }
};
const COMPETITION_TYPES = Object.values(CompetitionType);
const COMPETITION_STATUSES = Object.values(CompetitionStatus);
function isCompetitionType(typeString) {
    return typeString in CompetitionTypeProps;
}
function isCompetitionStatus(statusString) {
    return statusString in CompetitionStatusProps;
}

const CountryProps = {
    [Country.AD]: { code: 'AD', name: 'Andorra' },
    [Country.AE]: { code: 'AE', name: 'United Arab Emirates' },
    [Country.AF]: { code: 'AF', name: 'Afghanistan' },
    [Country.AG]: { code: 'AG', name: 'Antigua and Barbuda' },
    [Country.AI]: { code: 'AI', name: 'Anguilla' },
    [Country.AL]: { code: 'AL', name: 'Albania' },
    [Country.AM]: { code: 'AM', name: 'Armenia' },
    [Country.AO]: { code: 'AO', name: 'Angola' },
    [Country.AQ]: { code: 'AQ', name: 'Antarctica' },
    [Country.AR]: { code: 'AR', name: 'Argentina' },
    [Country.AS]: { code: 'AS', name: 'American Samoa' },
    [Country.AT]: { code: 'AT', name: 'Austria' },
    [Country.AU]: { code: 'AU', name: 'Australia' },
    [Country.AW]: { code: 'AW', name: 'Aruba' },
    [Country.AX]: { code: 'AX', name: 'Åland Islands' },
    [Country.AZ]: { code: 'AZ', name: 'Azerbaijan' },
    [Country.BA]: { code: 'BA', name: 'Bosnia and Herzegovina' },
    [Country.BB]: { code: 'BB', name: 'Barbados' },
    [Country.BD]: { code: 'BD', name: 'Bangladesh' },
    [Country.BE]: { code: 'BE', name: 'Belgium' },
    [Country.BF]: { code: 'BF', name: 'Burkina Faso' },
    [Country.BG]: { code: 'BG', name: 'Bulgaria' },
    [Country.BH]: { code: 'BH', name: 'Bahrain' },
    [Country.BI]: { code: 'BI', name: 'Burundi' },
    [Country.BJ]: { code: 'BJ', name: 'Benin' },
    [Country.BL]: { code: 'BL', name: 'Saint Barthélemy' },
    [Country.BM]: { code: 'BM', name: 'Bermuda' },
    [Country.BN]: { code: 'BN', name: 'Brunei Darussalam' },
    [Country.BO]: { code: 'BO', name: 'Bolivia' },
    [Country.BQ]: { code: 'BQ', name: 'Bonaire' },
    [Country.BR]: { code: 'BR', name: 'Brazil' },
    [Country.BS]: { code: 'BS', name: 'Bahamas' },
    [Country.BT]: { code: 'BT', name: 'Bhutan' },
    [Country.BV]: { code: 'BV', name: 'Bouvet Island' },
    [Country.BW]: { code: 'BW', name: 'Botswana' },
    [Country.BY]: { code: 'BY', name: 'Belarus' },
    [Country.BZ]: { code: 'BZ', name: 'Belize' },
    [Country.CA]: { code: 'CA', name: 'Canada' },
    [Country.CC]: { code: 'CC', name: 'Cocos (Keeling) Islands' },
    [Country.CD]: { code: 'CD', name: 'Congo' },
    [Country.CF]: { code: 'CF', name: 'Central African Republic' },
    [Country.CG]: { code: 'CG', name: 'Congo' },
    [Country.CH]: { code: 'CH', name: 'Switzerland' },
    [Country.CI]: { code: 'CI', name: "Côte d'Ivoire" },
    [Country.CK]: { code: 'CK', name: 'Cook Islands' },
    [Country.CL]: { code: 'CL', name: 'Chile' },
    [Country.CM]: { code: 'CM', name: 'Cameroon' },
    [Country.CN]: { code: 'CN', name: 'China' },
    [Country.CO]: { code: 'CO', name: 'Colombia' },
    [Country.CR]: { code: 'CR', name: 'Costa Rica' },
    [Country.CU]: { code: 'CU', name: 'Cuba' },
    [Country.CV]: { code: 'CV', name: 'Cabo Verde' },
    [Country.CW]: { code: 'CW', name: 'Curaçao' },
    [Country.CX]: { code: 'CX', name: 'Christmas Island' },
    [Country.CY]: { code: 'CY', name: 'Cyprus' },
    [Country.CZ]: { code: 'CZ', name: 'Czechia' },
    [Country.DE]: { code: 'DE', name: 'Germany' },
    [Country.DJ]: { code: 'DJ', name: 'Djibouti' },
    [Country.DK]: { code: 'DK', name: 'Denmark' },
    [Country.DM]: { code: 'DM', name: 'Dominica' },
    [Country.DO]: { code: 'DO', name: 'Dominican Republic' },
    [Country.DZ]: { code: 'DZ', name: 'Algeria' },
    [Country.EC]: { code: 'EC', name: 'Ecuador' },
    [Country.EE]: { code: 'EE', name: 'Estonia' },
    [Country.EG]: { code: 'EG', name: 'Egypt' },
    [Country.EH]: { code: 'EH', name: 'Western Sahara' },
    [Country.ER]: { code: 'ER', name: 'Eritrea' },
    [Country.ES]: { code: 'ES', name: 'Spain' },
    [Country.ET]: { code: 'ET', name: 'Ethiopia' },
    [Country.FI]: { code: 'FI', name: 'Finland' },
    [Country.FJ]: { code: 'FJ', name: 'Fiji' },
    [Country.FK]: { code: 'FK', name: 'Falkland Islands (Malvinas)' },
    [Country.FM]: { code: 'FM', name: 'Micronesia (Federated States of)' },
    [Country.FO]: { code: 'FO', name: 'Faroe Islands' },
    [Country.FR]: { code: 'FR', name: 'France' },
    [Country.GA]: { code: 'GA', name: 'Gabon' },
    [Country.GB]: { code: 'GB', name: 'United Kingdom' },
    [Country.GB_NIR]: { code: 'GB_NIR', name: 'Northen Ireland' },
    [Country.GB_SCT]: { code: 'GB_SCT', name: 'Scotland' },
    [Country.GB_WLS]: { code: 'GB_WLS', name: 'Wales' },
    [Country.GD]: { code: 'GD', name: 'Grenada' },
    [Country.GE]: { code: 'GE', name: 'Georgia' },
    [Country.GF]: { code: 'GF', name: 'French Guiana' },
    [Country.GG]: { code: 'GG', name: 'Guernsey' },
    [Country.GH]: { code: 'GH', name: 'Ghana' },
    [Country.GI]: { code: 'GI', name: 'Gibraltar' },
    [Country.GL]: { code: 'GL', name: 'Greenland' },
    [Country.GM]: { code: 'GM', name: 'Gambia' },
    [Country.GN]: { code: 'GN', name: 'Guinea' },
    [Country.GP]: { code: 'GP', name: 'Guadeloupe' },
    [Country.GQ]: { code: 'GQ', name: 'Equatorial Guinea' },
    [Country.GR]: { code: 'GR', name: 'Greece' },
    [Country.GS]: { code: 'GS', name: 'South Georgia and the South Sandwich Islands' },
    [Country.GT]: { code: 'GT', name: 'Guatemala' },
    [Country.GU]: { code: 'GU', name: 'Guam' },
    [Country.GW]: { code: 'GW', name: 'Guinea-Bissau' },
    [Country.GY]: { code: 'GY', name: 'Guyana' },
    [Country.HK]: { code: 'HK', name: 'Hong Kong' },
    [Country.HM]: { code: 'HM', name: 'Heard Island and McDonald Islands' },
    [Country.HN]: { code: 'HN', name: 'Honduras' },
    [Country.HR]: { code: 'HR', name: 'Croatia' },
    [Country.HT]: { code: 'HT', name: 'Haiti' },
    [Country.HU]: { code: 'HU', name: 'Hungary' },
    [Country.ID]: { code: 'ID', name: 'Indonesia' },
    [Country.IE]: { code: 'IE', name: 'Ireland' },
    [Country.IL]: { code: 'IL', name: 'Israel' },
    [Country.IM]: { code: 'IM', name: 'Isle of Man' },
    [Country.IN]: { code: 'IN', name: 'India' },
    [Country.IO]: { code: 'IO', name: 'British Indian Ocean Territory' },
    [Country.IQ]: { code: 'IQ', name: 'Iraq' },
    [Country.IR]: { code: 'IR', name: 'Iran (Islamic Republic of)' },
    [Country.IS]: { code: 'IS', name: 'Iceland' },
    [Country.IT]: { code: 'IT', name: 'Italy' },
    [Country.JE]: { code: 'JE', name: 'Jersey' },
    [Country.JM]: { code: 'JM', name: 'Jamaica' },
    [Country.JO]: { code: 'JO', name: 'Jordan' },
    [Country.JP]: { code: 'JP', name: 'Japan' },
    [Country.KE]: { code: 'KE', name: 'Kenya' },
    [Country.KG]: { code: 'KG', name: 'Kyrgyzstan' },
    [Country.KH]: { code: 'KH', name: 'Cambodia' },
    [Country.KI]: { code: 'KI', name: 'Kiribati' },
    [Country.KM]: { code: 'KM', name: 'Comoros' },
    [Country.KN]: { code: 'KN', name: 'Saint Kitts and Nevis' },
    [Country.KP]: { code: 'KP', name: "Korea (Democratic People's Republic of)" },
    [Country.KR]: { code: 'KR', name: 'Korea' },
    [Country.KW]: { code: 'KW', name: 'Kuwait' },
    [Country.KY]: { code: 'KY', name: 'Cayman Islands' },
    [Country.KZ]: { code: 'KZ', name: 'Kazakhstan' },
    [Country.LA]: { code: 'LA', name: "Lao People's Democratic Republic" },
    [Country.LB]: { code: 'LB', name: 'Lebanon' },
    [Country.LC]: { code: 'LC', name: 'Saint Lucia' },
    [Country.LI]: { code: 'LI', name: 'Liechtenstein' },
    [Country.LK]: { code: 'LK', name: 'Sri Lanka' },
    [Country.LR]: { code: 'LR', name: 'Liberia' },
    [Country.LS]: { code: 'LS', name: 'Lesotho' },
    [Country.LT]: { code: 'LT', name: 'Lithuania' },
    [Country.LU]: { code: 'LU', name: 'Luxembourg' },
    [Country.LV]: { code: 'LV', name: 'Latvia' },
    [Country.LY]: { code: 'LY', name: 'Libya' },
    [Country.MA]: { code: 'MA', name: 'Morocco' },
    [Country.MC]: { code: 'MC', name: 'Monaco' },
    [Country.MD]: { code: 'MD', name: 'Moldova' },
    [Country.ME]: { code: 'ME', name: 'Montenegro' },
    [Country.MF]: { code: 'MF', name: 'Saint Martin (French part)' },
    [Country.MG]: { code: 'MG', name: 'Madagascar' },
    [Country.MH]: { code: 'MH', name: 'Marshall Islands' },
    [Country.MK]: { code: 'MK', name: 'North Macedonia' },
    [Country.ML]: { code: 'ML', name: 'Mali' },
    [Country.MM]: { code: 'MM', name: 'Myanmar' },
    [Country.MN]: { code: 'MN', name: 'Mongolia' },
    [Country.MO]: { code: 'MO', name: 'Macao' },
    [Country.MP]: { code: 'MP', name: 'Northern Mariana Islands' },
    [Country.MQ]: { code: 'MQ', name: 'Martinique' },
    [Country.MR]: { code: 'MR', name: 'Mauritania' },
    [Country.MS]: { code: 'MS', name: 'Montserrat' },
    [Country.MT]: { code: 'MT', name: 'Malta' },
    [Country.MU]: { code: 'MU', name: 'Mauritius' },
    [Country.MV]: { code: 'MV', name: 'Maldives' },
    [Country.MW]: { code: 'MW', name: 'Malawi' },
    [Country.MX]: { code: 'MX', name: 'Mexico' },
    [Country.MY]: { code: 'MY', name: 'Malaysia' },
    [Country.MZ]: { code: 'MZ', name: 'Mozambique' },
    [Country.NA]: { code: 'NA', name: 'Namibia' },
    [Country.NC]: { code: 'NC', name: 'New Caledonia' },
    [Country.NE]: { code: 'NE', name: 'Niger' },
    [Country.NF]: { code: 'NF', name: 'Norfolk Island' },
    [Country.NG]: { code: 'NG', name: 'Nigeria' },
    [Country.NI]: { code: 'NI', name: 'Nicaragua' },
    [Country.NL]: { code: 'NL', name: 'Netherlands' },
    [Country.NO]: { code: 'NO', name: 'Norway' },
    [Country.NP]: { code: 'NP', name: 'Nepal' },
    [Country.NR]: { code: 'NR', name: 'Nauru' },
    [Country.NU]: { code: 'NU', name: 'Niue' },
    [Country.NZ]: { code: 'NZ', name: 'New Zealand' },
    [Country.OM]: { code: 'OM', name: 'Oman' },
    [Country.PA]: { code: 'PA', name: 'Panama' },
    [Country.PE]: { code: 'PE', name: 'Peru' },
    [Country.PF]: { code: 'PF', name: 'French Polynesia' },
    [Country.PG]: { code: 'PG', name: 'Papua New Guinea' },
    [Country.PH]: { code: 'PH', name: 'Philippines' },
    [Country.PK]: { code: 'PK', name: 'Pakistan' },
    [Country.PL]: { code: 'PL', name: 'Poland' },
    [Country.PM]: { code: 'PM', name: 'Saint Pierre and Miquelon' },
    [Country.PN]: { code: 'PN', name: 'Pitcairn' },
    [Country.PR]: { code: 'PR', name: 'Puerto Rico' },
    [Country.PS]: { code: 'PS', name: 'Palestine' },
    [Country.PT]: { code: 'PT', name: 'Portugal' },
    [Country.PW]: { code: 'PW', name: 'Palau' },
    [Country.PY]: { code: 'PY', name: 'Paraguay' },
    [Country.QA]: { code: 'QA', name: 'Qatar' },
    [Country.RE]: { code: 'RE', name: 'Réunion' },
    [Country.RO]: { code: 'RO', name: 'Romania' },
    [Country.RS]: { code: 'RS', name: 'Serbia' },
    [Country.RU]: { code: 'RU', name: 'Russian Federation' },
    [Country.RW]: { code: 'RW', name: 'Rwanda' },
    [Country.SA]: { code: 'SA', name: 'Saudi Arabia' },
    [Country.SB]: { code: 'SB', name: 'Solomon Islands' },
    [Country.SC]: { code: 'SC', name: 'Seychelles' },
    [Country.SD]: { code: 'SD', name: 'Sudan' },
    [Country.SE]: { code: 'SE', name: 'Sweden' },
    [Country.SG]: { code: 'SG', name: 'Singapore' },
    [Country.SH]: { code: 'SH', name: 'Saint Helena' },
    [Country.SI]: { code: 'SI', name: 'Slovenia' },
    [Country.SJ]: { code: 'SJ', name: 'Svalbard and Jan Mayen' },
    [Country.SK]: { code: 'SK', name: 'Slovakia' },
    [Country.SL]: { code: 'SL', name: 'Sierra Leone' },
    [Country.SM]: { code: 'SM', name: 'San Marino' },
    [Country.SN]: { code: 'SN', name: 'Senegal' },
    [Country.SO]: { code: 'SO', name: 'Somalia' },
    [Country.SR]: { code: 'SR', name: 'Suriname' },
    [Country.SS]: { code: 'SS', name: 'South Sudan' },
    [Country.ST]: { code: 'ST', name: 'Sao Tome and Principe' },
    [Country.SV]: { code: 'SV', name: 'El Salvador' },
    [Country.SX]: { code: 'SX', name: 'Sint Maarten (Dutch part)' },
    [Country.SY]: { code: 'SY', name: 'Syrian Arab Republic' },
    [Country.SZ]: { code: 'SZ', name: 'Eswatini' },
    [Country.TC]: { code: 'TC', name: 'Turks and Caicos Islands' },
    [Country.TD]: { code: 'TD', name: 'Chad' },
    [Country.TF]: { code: 'TF', name: 'French Southern Territories' },
    [Country.TG]: { code: 'TG', name: 'Togo' },
    [Country.TH]: { code: 'TH', name: 'Thailand' },
    [Country.TJ]: { code: 'TJ', name: 'Tajikistan' },
    [Country.TK]: { code: 'TK', name: 'Tokelau' },
    [Country.TL]: { code: 'TL', name: 'Timor-Leste' },
    [Country.TM]: { code: 'TM', name: 'Turkmenistan' },
    [Country.TN]: { code: 'TN', name: 'Tunisia' },
    [Country.TO]: { code: 'TO', name: 'Tonga' },
    [Country.TR]: { code: 'TR', name: 'Turkey' },
    [Country.TT]: { code: 'TT', name: 'Trinidad and Tobago' },
    [Country.TV]: { code: 'TV', name: 'Tuvalu' },
    [Country.TW]: { code: 'TW', name: 'Taiwan' },
    [Country.TZ]: { code: 'TZ', name: 'Tanzania' },
    [Country.UA]: { code: 'UA', name: 'Ukraine' },
    [Country.UG]: { code: 'UG', name: 'Uganda' },
    [Country.UM]: { code: 'UM', name: 'United States Minor Outlying Islands' },
    [Country.US]: { code: 'US', name: 'United States of America' },
    [Country.UY]: { code: 'UY', name: 'Uruguay' },
    [Country.UZ]: { code: 'UZ', name: 'Uzbekistan' },
    [Country.VA]: { code: 'VA', name: 'Holy See' },
    [Country.VC]: { code: 'VC', name: 'Saint Vincent and the Grenadines' },
    [Country.VE]: { code: 'VE', name: 'Venezuela (Bolivarian Republic of)' },
    [Country.VG]: { code: 'VG', name: 'Virgin Islands (British)' },
    [Country.VI]: { code: 'VI', name: 'Virgin Islands (U.S.)' },
    [Country.VN]: { code: 'VN', name: 'Viet Nam' },
    [Country.VU]: { code: 'VU', name: 'Vanuatu' },
    [Country.WF]: { code: 'WF', name: 'Wallis and Futuna' },
    [Country.WS]: { code: 'WS', name: 'Samoa' },
    [Country.YE]: { code: 'YE', name: 'Yemen' },
    [Country.YT]: { code: 'YT', name: 'Mayotte' },
    [Country.ZA]: { code: 'ZA', name: 'South Africa' },
    [Country.ZM]: { code: 'ZM', name: 'Zambia' },
    [Country.ZW]: { code: 'ZW', name: 'Zimbabwe' }
};
const COUNTRY_CODES = Object.values(Country);
const COMMON_ALIASES = [
    { commonIdentifier: 'UK', trueIdentifier: 'GB' },
    { commonIdentifier: 'USA', trueIdentifier: 'US' }
];
function isCountry(countryCodeString) {
    return countryCodeString in CountryProps;
}
function findCountry(countryIdentifier) {
    return findCountryByCode(countryIdentifier) || findCountryByName(countryIdentifier);
}
function findCountryByName(countryName) {
    return Object.values(CountryProps).find(c => c.name.toUpperCase() === countryName.toUpperCase());
}
function findCountryByCode(countryCode) {
    return Object.values(CountryProps).find(c => c.code === replaceCommonAliases(countryCode.toUpperCase()));
}
function replaceCommonAliases(countryCode) {
    var _a;
    if (!countryCode)
        return null;
    return ((_a = COMMON_ALIASES.find(ca => ca.commonIdentifier === countryCode)) === null || _a === void 0 ? void 0 : _a.trueIdentifier) || countryCode;
}

// Maximum effective skill level at 13,034,431 experience.
const MAX_LEVEL = 99;
// The maximum virtual skill level for any skill (200M experience).
const MAX_VIRTUAL_LEVEL = 126;
// The maximum skill experience (200M experience).
const MAX_SKILL_EXP = 200000000;
// The minimum skill exp for level 99
const SKILL_EXP_AT_99 = 13034431;
// The maximum skill at exactly 99 on all skills
const CAPPED_MAX_TOTAL_XP = 23 * SKILL_EXP_AT_99;
// Builds a lookup table for each level's required experience
// exp = XP_FOR_LEVEL[level - 1] || 13m = XP_FOR_LEVEL[98]
const XP_FOR_LEVEL = (function () {
    let xp = 0;
    const array = [];
    for (let level = 1; level <= MAX_VIRTUAL_LEVEL; ++level) {
        array[level - 1] = Math.floor(xp / 4);
        xp += Math.floor(level + 300 * Math.pow(2, level / 7));
    }
    return array;
})();
function getExpForLevel(level) {
    if (level < 1 || level > MAX_VIRTUAL_LEVEL)
        return 0;
    return XP_FOR_LEVEL[level - 1];
}
function getLevel(exp, virtual = false) {
    if (!exp || exp < 0) {
        return 1;
    }
    let low = 0;
    let high = virtual ? XP_FOR_LEVEL.length - 1 : 98;
    while (low <= high) {
        const mid = Math.floor(low + (high - low) / 2);
        const xpForLevel = XP_FOR_LEVEL[mid];
        if (exp < xpForLevel) {
            high = mid - 1;
        }
        else if (exp > xpForLevel) {
            low = mid + 1;
        }
        else {
            return mid + 1;
        }
    }
    return high + 1;
}
function getCombatLevel(attack, strength, defence, ranged, magic, hitpoints, prayer) {
    if ([attack, strength, defence, ranged, magic, hitpoints, prayer].some(l => l === 0))
        return 0;
    const baseCombat = 0.25 * (defence + Math.max(hitpoints, 10) + Math.floor(prayer / 2));
    const meleeCombat = 0.325 * (attack + strength);
    const rangeCombat = 0.325 * Math.floor((3 * ranged) / 2);
    const mageCombat = 0.325 * Math.floor((3 * magic) / 2);
    return Math.floor(baseCombat + Math.max(meleeCombat, rangeCombat, mageCombat));
}

function mapValues(obj, callback) {
    const clone = {};
    Object.keys(obj).forEach(k => {
        const key = k;
        clone[key] = callback(obj[key], key, obj);
    });
    return clone;
}

const GROUP_ROLES = Object.values(GroupRole);
const PRIVELEGED_GROUP_ROLES = [
    GroupRole.ADMINISTRATOR,
    GroupRole.OWNER,
    GroupRole.LEADER,
    GroupRole.DEPUTY_OWNER,
    GroupRole.MODERATOR
];
const GroupRoleProps = mapValues({
    [GroupRole.ACHIEVER]: { name: 'Achiever' },
    [GroupRole.ADAMANT]: { name: 'Adamant' },
    [GroupRole.ADEPT]: { name: 'Adept' },
    [GroupRole.ADMINISTRATOR]: { name: 'Administrator' },
    [GroupRole.ADMIRAL]: { name: 'Admiral' },
    [GroupRole.ADVENTURER]: { name: 'Adventurer' },
    [GroupRole.AIR]: { name: 'Air' },
    [GroupRole.ANCHOR]: { name: 'Anchor' },
    [GroupRole.APOTHECARY]: { name: 'Apothecary' },
    [GroupRole.ARCHER]: { name: 'Archer' },
    [GroupRole.ARMADYLEAN]: { name: 'Armadylean' },
    [GroupRole.ARTILLERY]: { name: 'Artillery' },
    [GroupRole.ARTISAN]: { name: 'Artisan' },
    [GroupRole.ASGARNIAN]: { name: 'Asgarnian' },
    [GroupRole.ASSASSIN]: { name: 'Assassin' },
    [GroupRole.ASSISTANT]: { name: 'Assistant' },
    [GroupRole.ASTRAL]: { name: 'Astral' },
    [GroupRole.ATHLETE]: { name: 'Athlete' },
    [GroupRole.ATTACKER]: { name: 'Attacker' },
    [GroupRole.BANDIT]: { name: 'Bandit' },
    [GroupRole.BANDOSIAN]: { name: 'Bandosian' },
    [GroupRole.BARBARIAN]: { name: 'Barbarian' },
    [GroupRole.BATTLEMAGE]: { name: 'Battlemage' },
    [GroupRole.BEAST]: { name: 'Beast' },
    [GroupRole.BERSERKER]: { name: 'Berserker' },
    [GroupRole.BLISTERWOOD]: { name: 'Blisterwood' },
    [GroupRole.BLOOD]: { name: 'Blood' },
    [GroupRole.BLUE]: { name: 'Blue' },
    [GroupRole.BOB]: { name: 'Bob' },
    [GroupRole.BODY]: { name: 'Body' },
    [GroupRole.BRASSICAN]: { name: 'Brassican' },
    [GroupRole.BRAWLER]: { name: 'Brawler' },
    [GroupRole.BRIGADIER]: { name: 'Brigadier' },
    [GroupRole.BRIGAND]: { name: 'Brigand' },
    [GroupRole.BRONZE]: { name: 'Bronze' },
    [GroupRole.BRUISER]: { name: 'Bruiser' },
    [GroupRole.BULWARK]: { name: 'Bulwark' },
    [GroupRole.BURGLAR]: { name: 'Burglar' },
    [GroupRole.BURNT]: { name: 'Burnt' },
    [GroupRole.CADET]: { name: 'Cadet' },
    [GroupRole.CAPTAIN]: { name: 'Captain' },
    [GroupRole.CARRY]: { name: 'Carry' },
    [GroupRole.CHAMPION]: { name: 'Champion' },
    [GroupRole.CHAOS]: { name: 'Chaos' },
    [GroupRole.CLERIC]: { name: 'Cleric' },
    [GroupRole.COLLECTOR]: { name: 'Collector' },
    [GroupRole.COLONEL]: { name: 'Colonel' },
    [GroupRole.COMMANDER]: { name: 'Commander' },
    [GroupRole.COMPETITOR]: { name: 'Competitor' },
    [GroupRole.COMPLETIONIST]: { name: 'Completionist' },
    [GroupRole.CONSTRUCTOR]: { name: 'Constructor' },
    [GroupRole.COOK]: { name: 'Cook' },
    [GroupRole.COORDINATOR]: { name: 'Coordinator' },
    [GroupRole.CORPORAL]: { name: 'Corporal' },
    [GroupRole.COSMIC]: { name: 'Cosmic' },
    [GroupRole.COUNCILLOR]: { name: 'Councillor' },
    [GroupRole.CRAFTER]: { name: 'Crafter' },
    [GroupRole.CREW]: { name: 'Crew' },
    [GroupRole.CRUSADER]: { name: 'Crusader' },
    [GroupRole.CUTPURSE]: { name: 'Cutpurse' },
    [GroupRole.DEATH]: { name: 'Death' },
    [GroupRole.DEFENDER]: { name: 'Defender' },
    [GroupRole.DEFILER]: { name: 'Defiler' },
    [GroupRole.DEPUTY_OWNER]: { name: 'Deputy Owner' },
    [GroupRole.DESTROYER]: { name: 'Destroyer' },
    [GroupRole.DIAMOND]: { name: 'Diamond' },
    [GroupRole.DISEASED]: { name: 'Diseased' },
    [GroupRole.DOCTOR]: { name: 'Doctor' },
    [GroupRole.DOGSBODY]: { name: 'Dogsbody' },
    [GroupRole.DRAGON]: { name: 'Dragon' },
    [GroupRole.DRAGONSTONE]: { name: 'Dragonstone' },
    [GroupRole.DRUID]: { name: 'Druid' },
    [GroupRole.DUELLIST]: { name: 'Duellist' },
    [GroupRole.EARTH]: { name: 'Earth' },
    [GroupRole.ELITE]: { name: 'Elite' },
    [GroupRole.EMERALD]: { name: 'Emerald' },
    [GroupRole.ENFORCER]: { name: 'Enforcer' },
    [GroupRole.EPIC]: { name: 'Epic' },
    [GroupRole.EXECUTIVE]: { name: 'Executive' },
    [GroupRole.EXPERT]: { name: 'Expert' },
    [GroupRole.EXPLORER]: { name: 'Explorer' },
    [GroupRole.FARMER]: { name: 'Farmer' },
    [GroupRole.FEEDER]: { name: 'Feeder' },
    [GroupRole.FIGHTER]: { name: 'Fighter' },
    [GroupRole.FIRE]: { name: 'Fire' },
    [GroupRole.FIREMAKER]: { name: 'Firemaker' },
    [GroupRole.FIRESTARTER]: { name: 'Firestarter' },
    [GroupRole.FISHER]: { name: 'Fisher' },
    [GroupRole.FLETCHER]: { name: 'Fletcher' },
    [GroupRole.FORAGER]: { name: 'Forager' },
    [GroupRole.FREMENNIK]: { name: 'Fremennik' },
    [GroupRole.GAMER]: { name: 'Gamer' },
    [GroupRole.GATHERER]: { name: 'Gatherer' },
    [GroupRole.GENERAL]: { name: 'General' },
    [GroupRole.GNOME_CHILD]: { name: 'Gnome Child' },
    [GroupRole.GNOME_ELDER]: { name: 'Gnome Elder' },
    [GroupRole.GOBLIN]: { name: 'Goblin' },
    [GroupRole.GOLD]: { name: 'Gold' },
    [GroupRole.GOON]: { name: 'Goon' },
    [GroupRole.GREEN]: { name: 'Green' },
    [GroupRole.GREY]: { name: 'Grey' },
    [GroupRole.GUARDIAN]: { name: 'Guardian' },
    [GroupRole.GUTHIXIAN]: { name: 'Guthixian' },
    [GroupRole.HARPOON]: { name: 'Harpoon' },
    [GroupRole.HEALER]: { name: 'Healer' },
    [GroupRole.HELLCAT]: { name: 'Hellcat' },
    [GroupRole.HELPER]: { name: 'Helper' },
    [GroupRole.HERBOLOGIST]: { name: 'Herbologist' },
    [GroupRole.HERO]: { name: 'Hero' },
    [GroupRole.HOLY]: { name: 'Holy' },
    [GroupRole.HOARDER]: { name: 'Hoarder' },
    [GroupRole.HUNTER]: { name: 'Hunter' },
    [GroupRole.IGNITOR]: { name: 'Ignitor' },
    [GroupRole.ILLUSIONIST]: { name: 'Illusionist' },
    [GroupRole.IMP]: { name: 'Imp' },
    [GroupRole.INFANTRY]: { name: 'Infantry' },
    [GroupRole.INQUISITOR]: { name: 'Inquisitor' },
    [GroupRole.IRON]: { name: 'Iron' },
    [GroupRole.JADE]: { name: 'Jade' },
    [GroupRole.JUSTICIAR]: { name: 'Justiciar' },
    [GroupRole.KANDARIN]: { name: 'Kandarin' },
    [GroupRole.KARAMJAN]: { name: 'Karamjan' },
    [GroupRole.KHARIDIAN]: { name: 'Kharidian' },
    [GroupRole.KITTEN]: { name: 'Kitten' },
    [GroupRole.KNIGHT]: { name: 'Knight' },
    [GroupRole.LABOURER]: { name: 'Labourer' },
    [GroupRole.LAW]: { name: 'Law' },
    [GroupRole.LEADER]: { name: 'Leader' },
    [GroupRole.LEARNER]: { name: 'Learner' },
    [GroupRole.LEGACY]: { name: 'Legacy' },
    [GroupRole.LEGEND]: { name: 'Legend' },
    [GroupRole.LEGIONNAIRE]: { name: 'Legionnaire' },
    [GroupRole.LIEUTENANT]: { name: 'Lieutenant' },
    [GroupRole.LOOTER]: { name: 'Looter' },
    [GroupRole.LUMBERJACK]: { name: 'Lumberjack' },
    [GroupRole.MAGIC]: { name: 'Magic' },
    [GroupRole.MAGICIAN]: { name: 'Magician' },
    [GroupRole.MAJOR]: { name: 'Major' },
    [GroupRole.MAPLE]: { name: 'Maple' },
    [GroupRole.MARSHAL]: { name: 'Marshal' },
    [GroupRole.MASTER]: { name: 'Master' },
    [GroupRole.MAXED]: { name: 'Maxed' },
    [GroupRole.MEDIATOR]: { name: 'Mediator' },
    [GroupRole.MEDIC]: { name: 'Medic' },
    [GroupRole.MENTOR]: { name: 'Mentor' },
    [GroupRole.MEMBER]: { name: 'Member' },
    [GroupRole.MERCHANT]: { name: 'Merchant' },
    [GroupRole.MIND]: { name: 'Mind' },
    [GroupRole.MINER]: { name: 'Miner' },
    [GroupRole.MINION]: { name: 'Minion' },
    [GroupRole.MISTHALINIAN]: { name: 'Misthalinian' },
    [GroupRole.MITHRIL]: { name: 'Mithril' },
    [GroupRole.MODERATOR]: { name: 'Moderator' },
    [GroupRole.MONARCH]: { name: 'Monarch' },
    [GroupRole.MORYTANIAN]: { name: 'Morytanian' },
    [GroupRole.MYSTIC]: { name: 'Mystic' },
    [GroupRole.MYTH]: { name: 'Myth' },
    [GroupRole.NATURAL]: { name: 'Natural' },
    [GroupRole.NATURE]: { name: 'Nature' },
    [GroupRole.NECROMANCER]: { name: 'Necromancer' },
    [GroupRole.NINJA]: { name: 'Ninja' },
    [GroupRole.NOBLE]: { name: 'Noble' },
    [GroupRole.NOVICE]: { name: 'Novice' },
    [GroupRole.NURSE]: { name: 'Nurse' },
    [GroupRole.OAK]: { name: 'Oak' },
    [GroupRole.OFFICER]: { name: 'Officer' },
    [GroupRole.ONYX]: { name: 'Onyx' },
    [GroupRole.OPAL]: { name: 'Opal' },
    [GroupRole.ORACLE]: { name: 'Oracle' },
    [GroupRole.ORANGE]: { name: 'Orange' },
    [GroupRole.OWNER]: { name: 'Owner' },
    [GroupRole.PAGE]: { name: 'Page' },
    [GroupRole.PALADIN]: { name: 'Paladin' },
    [GroupRole.PAWN]: { name: 'Pawn' },
    [GroupRole.PILGRIM]: { name: 'Pilgrim' },
    [GroupRole.PINE]: { name: 'Pine' },
    [GroupRole.PINK]: { name: 'Pink' },
    [GroupRole.PREFECT]: { name: 'Prefect' },
    [GroupRole.PRIEST]: { name: 'Priest' },
    [GroupRole.PRIVATE]: { name: 'Private' },
    [GroupRole.PRODIGY]: { name: 'Prodigy' },
    [GroupRole.PROSELYTE]: { name: 'Proselyte' },
    [GroupRole.PROSPECTOR]: { name: 'Prospector' },
    [GroupRole.PROTECTOR]: { name: 'Protector' },
    [GroupRole.PURE]: { name: 'Pure' },
    [GroupRole.PURPLE]: { name: 'Purple' },
    [GroupRole.PYROMANCER]: { name: 'Pyromancer' },
    [GroupRole.QUESTER]: { name: 'Quester' },
    [GroupRole.RACER]: { name: 'Racer' },
    [GroupRole.RAIDER]: { name: 'Raider' },
    [GroupRole.RANGER]: { name: 'Ranger' },
    [GroupRole.RECORD_CHASER]: { name: 'Record-Chaser' },
    [GroupRole.RECRUIT]: { name: 'Recruit' },
    [GroupRole.RECRUITER]: { name: 'Recruiter' },
    [GroupRole.RED_TOPAZ]: { name: 'Red Topaz' },
    [GroupRole.RED]: { name: 'Red' },
    [GroupRole.ROGUE]: { name: 'Rogue' },
    [GroupRole.RUBY]: { name: 'Ruby' },
    [GroupRole.RUNE]: { name: 'Rune' },
    [GroupRole.RUNECRAFTER]: { name: 'Runecrafter' },
    [GroupRole.SAGE]: { name: 'Sage' },
    [GroupRole.SAPPHIRE]: { name: 'Sapphire' },
    [GroupRole.SARADOMINIST]: { name: 'Saradominist' },
    [GroupRole.SAVIOUR]: { name: 'Saviour' },
    [GroupRole.SCAVENGER]: { name: 'Scavenger' },
    [GroupRole.SCHOLAR]: { name: 'Scholar' },
    [GroupRole.SCOURGE]: { name: 'Scourge' },
    [GroupRole.SCOUT]: { name: 'Scout' },
    [GroupRole.SCRIBE]: { name: 'Scribe' },
    [GroupRole.SEER]: { name: 'Seer' },
    [GroupRole.SENATOR]: { name: 'Senator' },
    [GroupRole.SENTRY]: { name: 'Sentry' },
    [GroupRole.SERENIST]: { name: 'Serenist' },
    [GroupRole.SERGEANT]: { name: 'Sergeant' },
    [GroupRole.SHAMAN]: { name: 'Shaman' },
    [GroupRole.SHERIFF]: { name: 'Sheriff' },
    [GroupRole.SHORT_GREEN_GUY]: { name: 'Short Green Guy' },
    [GroupRole.SKILLER]: { name: 'Skiller' },
    [GroupRole.SKULLED]: { name: 'Skulled' },
    [GroupRole.SLAYER]: { name: 'Slayer' },
    [GroupRole.SMITER]: { name: 'Smiter' },
    [GroupRole.SMITH]: { name: 'Smith' },
    [GroupRole.SMUGGLER]: { name: 'Smuggler' },
    [GroupRole.SNIPER]: { name: 'Sniper' },
    [GroupRole.SOUL]: { name: 'Soul' },
    [GroupRole.SPECIALIST]: { name: 'Specialist' },
    [GroupRole.SPEED_RUNNER]: { name: 'Speed-Runner' },
    [GroupRole.SPELLCASTER]: { name: 'Spellcaster' },
    [GroupRole.SQUIRE]: { name: 'Squire' },
    [GroupRole.STAFF]: { name: 'Staff' },
    [GroupRole.STEEL]: { name: 'Steel' },
    [GroupRole.STRIDER]: { name: 'Strider' },
    [GroupRole.STRIKER]: { name: 'Striker' },
    [GroupRole.SUMMONER]: { name: 'Summoner' },
    [GroupRole.SUPERIOR]: { name: 'Superior' },
    [GroupRole.SUPERVISOR]: { name: 'Supervisor' },
    [GroupRole.TEACHER]: { name: 'Teacher' },
    [GroupRole.TEMPLAR]: { name: 'Templar' },
    [GroupRole.THERAPIST]: { name: 'Therapist' },
    [GroupRole.THIEF]: { name: 'Thief' },
    [GroupRole.TIRANNIAN]: { name: 'Tirannian' },
    [GroupRole.TRIALIST]: { name: 'Trialist' },
    [GroupRole.TRICKSTER]: { name: 'Trickster' },
    [GroupRole.TZKAL]: { name: 'TzKal' },
    [GroupRole.TZTOK]: { name: 'TzTok' },
    [GroupRole.UNHOLY]: { name: 'Unholy' },
    [GroupRole.VAGRANT]: { name: 'Vagrant' },
    [GroupRole.VANGUARD]: { name: 'Vanguard' },
    [GroupRole.WALKER]: { name: 'Walker' },
    [GroupRole.WANDERER]: { name: 'Wanderer' },
    [GroupRole.WARDEN]: { name: 'Warden' },
    [GroupRole.WARLOCK]: { name: 'Warlock' },
    [GroupRole.WARRIOR]: { name: 'Warrior' },
    [GroupRole.WATER]: { name: 'Water' },
    [GroupRole.WILD]: { name: 'Wild' },
    [GroupRole.WILLOW]: { name: 'Willow' },
    [GroupRole.WILY]: { name: 'Wily' },
    [GroupRole.WINTUMBER]: { name: 'Wintumber' },
    [GroupRole.WITCH]: { name: 'Witch' },
    [GroupRole.WIZARD]: { name: 'Wizard' },
    [GroupRole.WORKER]: { name: 'Worker' },
    [GroupRole.WRATH]: { name: 'Wrath' },
    [GroupRole.XERICIAN]: { name: 'Xerician' },
    [GroupRole.YELLOW]: { name: 'Yellow' },
    [GroupRole.YEW]: { name: 'Yew' },
    [GroupRole.ZAMORAKIAN]: { name: 'Zamorakian' },
    [GroupRole.ZAROSIAN]: { name: 'Zarosian' },
    [GroupRole.ZEALOT]: { name: 'Zealot' },
    [GroupRole.ZENYTE]: { name: 'Zenyte' }
}, (props, key) => (Object.assign(Object.assign({}, props), { isPriveleged: PRIVELEGED_GROUP_ROLES.includes(key) })));
function findGroupRole(roleName) {
    for (const [key, value] of Object.entries(GroupRoleProps)) {
        if (value.name.toUpperCase() === roleName.toUpperCase()) {
            return key;
        }
    }
    return null;
}
function isGroupRole(roleString) {
    return roleString in GroupRoleProps;
}

var MetricType;
(function (MetricType) {
    MetricType["SKILL"] = "skill";
    MetricType["BOSS"] = "boss";
    MetricType["ACTIVITY"] = "activity";
    MetricType["COMPUTED"] = "computed";
})(MetricType || (MetricType = {}));
var MetricMeasure;
(function (MetricMeasure) {
    MetricMeasure["EXPERIENCE"] = "experience";
    MetricMeasure["KILLS"] = "kills";
    MetricMeasure["SCORE"] = "score";
    MetricMeasure["VALUE"] = "value";
})(MetricMeasure || (MetricMeasure = {}));
const SkillProps = mapValues({
    [Skill.OVERALL]: { name: 'Overall' },
    [Skill.ATTACK]: { name: 'Attack', isCombat: true },
    [Skill.DEFENCE]: { name: 'Defence', isCombat: true },
    [Skill.STRENGTH]: { name: 'Strength', isCombat: true },
    [Skill.HITPOINTS]: { name: 'Hitpoints', isCombat: true },
    [Skill.RANGED]: { name: 'Ranged', isCombat: true },
    [Skill.PRAYER]: { name: 'Prayer', isCombat: true },
    [Skill.MAGIC]: { name: 'Magic', isCombat: true },
    [Skill.COOKING]: { name: 'Cooking' },
    [Skill.WOODCUTTING]: { name: 'Woodcutting' },
    [Skill.FLETCHING]: { name: 'Fletching', isMembers: true },
    [Skill.FISHING]: { name: 'Fishing' },
    [Skill.FIREMAKING]: { name: 'Firemaking' },
    [Skill.CRAFTING]: { name: 'Crafting' },
    [Skill.SMITHING]: { name: 'Smithing' },
    [Skill.MINING]: { name: 'Mining' },
    [Skill.HERBLORE]: { name: 'Herblore', isMembers: true },
    [Skill.AGILITY]: { name: 'Agility', isMembers: true },
    [Skill.THIEVING]: { name: 'Thieving', isMembers: true },
    [Skill.SLAYER]: { name: 'Slayer', isMembers: true },
    [Skill.FARMING]: { name: 'Farming', isMembers: true },
    [Skill.RUNECRAFTING]: { name: 'Runecrafting' },
    [Skill.HUNTER]: { name: 'Hunter', isMembers: true },
    [Skill.CONSTRUCTION]: { name: 'Construction', isMembers: true }
}, props => (Object.assign(Object.assign({}, props), { type: MetricType.SKILL, measure: MetricMeasure.EXPERIENCE, isCombat: 'isCombat' in props ? props.isCombat : false, isMembers: 'isMembers' in props ? props.isMembers : false })));
const BossProps = mapValues({
    [Boss.ABYSSAL_SIRE]: { name: 'Abyssal Sire' },
    [Boss.ALCHEMICAL_HYDRA]: { name: 'Alchemical Hydra' },
    [Boss.AMOXLIATL]: { name: 'Amoxliatl' },
    [Boss.ARAXXOR]: { name: 'Araxxor' },
    [Boss.ARTIO]: { name: 'Artio' },
    [Boss.BARROWS_CHESTS]: { name: 'Barrows Chests' },
    [Boss.BRYOPHYTA]: { name: 'Bryophyta', isMembers: false },
    [Boss.CALLISTO]: { name: 'Callisto' },
    [Boss.CALVARION]: { name: "Calvar'ion" },
    [Boss.CERBERUS]: { name: 'Cerberus' },
    [Boss.CHAMBERS_OF_XERIC]: { name: 'Chambers Of Xeric' },
    [Boss.CHAMBERS_OF_XERIC_CM]: { name: 'Chambers Of Xeric (CM)' },
    [Boss.CHAOS_ELEMENTAL]: { name: 'Chaos Elemental' },
    [Boss.CHAOS_FANATIC]: { name: 'Chaos Fanatic' },
    [Boss.COMMANDER_ZILYANA]: { name: 'Commander Zilyana' },
    [Boss.CORPOREAL_BEAST]: { name: 'Corporeal Beast' },
    [Boss.CRAZY_ARCHAEOLOGIST]: { name: 'Crazy Archaeologist' },
    [Boss.DAGANNOTH_PRIME]: { name: 'Dagannoth Prime' },
    [Boss.DAGANNOTH_REX]: { name: 'Dagannoth Rex' },
    [Boss.DAGANNOTH_SUPREME]: { name: 'Dagannoth Supreme' },
    [Boss.DERANGED_ARCHAEOLOGIST]: { name: 'Deranged Archaeologist' },
    [Boss.DUKE_SUCELLUS]: { name: 'Duke Sucellus' },
    [Boss.GENERAL_GRAARDOR]: { name: 'General Graardor' },
    [Boss.GIANT_MOLE]: { name: 'Giant Mole' },
    [Boss.GROTESQUE_GUARDIANS]: { name: 'Grotesque Guardians' },
    [Boss.HESPORI]: { name: 'Hespori' },
    [Boss.THE_HUEYCOATL]: { name: 'The Hueycoatl' },
    [Boss.KALPHITE_QUEEN]: { name: 'Kalphite Queen' },
    [Boss.KING_BLACK_DRAGON]: { name: 'King Black Dragon' },
    [Boss.KRAKEN]: { name: 'Kraken' },
    [Boss.KREEARRA]: { name: "Kree'Arra" },
    [Boss.KRIL_TSUTSAROTH]: { name: "K'ril Tsutsaroth" },
    [Boss.LUNAR_CHESTS]: { name: 'Lunar Chests' },
    [Boss.MIMIC]: { name: 'Mimic', minimumValue: 1 },
    [Boss.NEX]: { name: 'Nex' },
    [Boss.NIGHTMARE]: { name: 'Nightmare' },
    [Boss.PHOSANIS_NIGHTMARE]: { name: "Phosani's Nightmare" },
    [Boss.OBOR]: { name: 'Obor', isMembers: false },
    [Boss.PHANTOM_MUSPAH]: { name: 'Phantom Muspah' },
    [Boss.SARACHNIS]: { name: 'Sarachnis' },
    [Boss.SCORPIA]: { name: 'Scorpia' },
    [Boss.SCURRIUS]: { name: 'Scurrius' },
    [Boss.SKOTIZO]: { name: 'Skotizo' },
    [Boss.SOL_HEREDIT]: { name: 'Sol Heredit' },
    [Boss.SPINDEL]: { name: 'Spindel' },
    [Boss.TEMPOROSS]: { name: 'Tempoross' },
    [Boss.THE_GAUNTLET]: { name: 'The Gauntlet' },
    [Boss.THE_CORRUPTED_GAUNTLET]: { name: 'The Corrupted Gauntlet' },
    [Boss.THE_LEVIATHAN]: { name: 'The Leviathan' },
    [Boss.THE_WHISPERER]: { name: 'The Whisperer' },
    [Boss.THEATRE_OF_BLOOD]: { name: 'Theatre Of Blood' },
    [Boss.THEATRE_OF_BLOOD_HARD_MODE]: { name: 'Theatre Of Blood (HM)' },
    [Boss.THERMONUCLEAR_SMOKE_DEVIL]: { name: 'Thermonuclear Smoke Devil' },
    [Boss.TOMBS_OF_AMASCUT]: { name: 'Tombs of Amascut' },
    [Boss.TOMBS_OF_AMASCUT_EXPERT]: { name: 'Tombs of Amascut (Expert Mode)' },
    [Boss.TZKAL_ZUK]: { name: 'TzKal-Zuk', minimumValue: 1 },
    [Boss.TZTOK_JAD]: { name: 'TzTok-Jad' },
    [Boss.VARDORVIS]: { name: 'Vardorvis' },
    [Boss.VENENATIS]: { name: 'Venenatis' },
    [Boss.VETION]: { name: "Vet'ion" },
    [Boss.VORKATH]: { name: 'Vorkath' },
    [Boss.WINTERTODT]: { name: 'Wintertodt' },
    [Boss.ZALCANO]: { name: 'Zalcano' },
    [Boss.ZULRAH]: { name: 'Zulrah' }
}, props => (Object.assign(Object.assign({}, props), { type: MetricType.BOSS, measure: MetricMeasure.KILLS, isMembers: 'isMembers' in props ? props.isMembers : true, minimumValue: 'minimumValue' in props ? props.minimumValue : 5 })));
const ActivityProps = mapValues({
    [Activity.LEAGUE_POINTS]: { name: 'League Points', minimumValue: 100 },
    [Activity.BOUNTY_HUNTER_HUNTER]: { name: 'Bounty Hunter (Hunter)', minimumValue: 2 },
    [Activity.BOUNTY_HUNTER_ROGUE]: { name: 'Bounty Hunter (Rogue)', minimumValue: 2 },
    [Activity.CLUE_SCROLLS_ALL]: { name: 'Clue Scrolls (All)' },
    [Activity.CLUE_SCROLLS_BEGINNER]: { name: 'Clue Scrolls (Beginner)' },
    [Activity.CLUE_SCROLLS_EASY]: { name: 'Clue Scrolls (Easy)' },
    [Activity.CLUE_SCROLLS_MEDIUM]: { name: 'Clue Scrolls (Medium)' },
    [Activity.CLUE_SCROLLS_HARD]: { name: 'Clue Scrolls (Hard)' },
    [Activity.CLUE_SCROLLS_ELITE]: { name: 'Clue Scrolls (Elite)' },
    [Activity.CLUE_SCROLLS_MASTER]: { name: 'Clue Scrolls (Master)' },
    [Activity.LAST_MAN_STANDING]: { name: 'Last Man Standing', minimumValue: 500 },
    [Activity.PVP_ARENA]: { name: 'PvP Arena', minimumValue: 2525 },
    [Activity.SOUL_WARS_ZEAL]: { name: 'Soul Wars Zeal', minimumValue: 200 },
    [Activity.GUARDIANS_OF_THE_RIFT]: { name: 'Guardians of the Rift', minimumValue: 2 },
    [Activity.COLOSSEUM_GLORY]: { name: 'Colosseum Glory', minimumValue: 300 }
}, props => (Object.assign(Object.assign({}, props), { type: MetricType.ACTIVITY, measure: MetricMeasure.SCORE, minimumValue: 'minimumValue' in props ? props.minimumValue : 1 })));
const ComputedMetricProps = mapValues({
    [ComputedMetric.EHP]: { name: 'EHP' },
    [ComputedMetric.EHB]: { name: 'EHB' }
}, props => (Object.assign(Object.assign({}, props), { type: MetricType.COMPUTED, measure: MetricMeasure.VALUE })));
const MetricProps = Object.assign(Object.assign(Object.assign(Object.assign({}, SkillProps), BossProps), ActivityProps), ComputedMetricProps);
const METRICS = Object.values(Metric);
const SKILLS = Object.values(Skill);
const BOSSES = Object.values(Boss);
const ACTIVITIES = Object.values(Activity);
const COMPUTED_METRICS = Object.values(ComputedMetric);
const REAL_SKILLS = SKILLS.filter(s => s !== Skill.OVERALL);
const F2P_BOSSES = BOSSES.filter(b => !MetricProps[b].isMembers);
const MEMBER_SKILLS = SKILLS.filter(s => MetricProps[s].isMembers);
const COMBAT_SKILLS = SKILLS.filter(s => MetricProps[s].isCombat);
const REAL_METRICS = [...SKILLS, ...BOSSES, ...ACTIVITIES];
function findMetric(metricName) {
    for (const [key, value] of Object.entries(MetricProps)) {
        if (value.name.toUpperCase() === metricName.toUpperCase())
            return key;
    }
    return null;
}
function isMetric(metric) {
    return metric in MetricProps;
}
function isSkill(metric) {
    return metric in SkillProps;
}
function isActivity(metric) {
    return metric in ActivityProps;
}
function isBoss(metric) {
    return metric in BossProps;
}
function isComputedMetric(metric) {
    return metric in ComputedMetricProps;
}
function getMetricRankKey(metric) {
    return `${metric}Rank`;
}
// Maybe someday I'll be good enough with TS to restrict the return type to the input metric type
function getMetricValueKey(metric) {
    if (isSkill(metric)) {
        return `${metric}Experience`;
    }
    if (isBoss(metric)) {
        return `${metric}Kills`;
    }
    if (isActivity(metric)) {
        return `${metric}Score`;
    }
    return `${metric}Value`;
}
function getMetricMeasure(metric) {
    return MetricProps[metric].measure;
}
function getMetricName(metric) {
    return MetricProps[metric].name;
}
function getMinimumValue(metric) {
    return isBoss(metric) || isActivity(metric) ? MetricProps[metric].minimumValue : 1;
}
function getParentEfficiencyMetric(metric) {
    if (isBoss(metric))
        return Metric.EHB;
    if (isSkill(metric))
        return Metric.EHP;
    return null;
}

const CUSTOM_PERIOD_REGEX = /(\d+y)?(\d+m)?(\d+w)?(\d+d)?(\d+h)?/;
const PeriodProps = {
    [Period.FIVE_MIN]: { name: '5 Min', milliseconds: 300000 },
    [Period.DAY]: { name: 'Day', milliseconds: 86400000 },
    [Period.WEEK]: { name: 'Week', milliseconds: 604800000 },
    [Period.MONTH]: { name: 'Month', milliseconds: 2678400000 },
    [Period.YEAR]: { name: 'Year', milliseconds: 31556926000 }
};
const PERIODS = Object.values(Period);
function findPeriod(periodName) {
    for (const [key, value] of Object.entries(PeriodProps)) {
        if (value.name.toUpperCase() === periodName.toUpperCase())
            return key;
    }
    return null;
}
function isPeriod(periodString) {
    return periodString in PeriodProps;
}
function parsePeriodExpression(periodExpression) {
    const fixed = periodExpression.toLowerCase();
    if (isPeriod(fixed)) {
        return {
            expression: fixed,
            durationMs: PeriodProps[fixed].milliseconds
        };
    }
    const result = fixed.match(CUSTOM_PERIOD_REGEX);
    if (!result || result.length === 0 || result[0] !== fixed)
        return null;
    const years = result[1] ? parseInt(result[1].replace(/\D/g, '')) : 0;
    const months = result[2] ? parseInt(result[2].replace(/\D/g, '')) : 0;
    const weeks = result[3] ? parseInt(result[3].replace(/\D/g, '')) : 0;
    const days = result[4] ? parseInt(result[4].replace(/\D/g, '')) : 0;
    const hours = result[5] ? parseInt(result[5].replace(/\D/g, '')) : 0;
    const yearsMs = years * PeriodProps[Period.YEAR].milliseconds;
    const monthsMs = months * PeriodProps[Period.MONTH].milliseconds;
    const weeksMs = weeks * PeriodProps[Period.WEEK].milliseconds;
    const daysMs = days * PeriodProps[Period.DAY].milliseconds;
    const hoursMs = hours * (PeriodProps[Period.DAY].milliseconds / 24);
    const totalMs = yearsMs + monthsMs + weeksMs + daysMs + hoursMs;
    return {
        expression: result[0],
        durationMs: totalMs
    };
}

const PlayerTypeProps = {
    [PlayerType.UNKNOWN]: { name: 'Unknown' },
    [PlayerType.REGULAR]: { name: 'Regular' },
    [PlayerType.IRONMAN]: { name: 'Ironman' },
    [PlayerType.HARDCORE]: { name: 'Hardcore' },
    [PlayerType.ULTIMATE]: { name: 'Ultimate' }
};
const PlayerBuildProps = {
    [PlayerBuild.MAIN]: { name: 'Main' },
    [PlayerBuild.F2P]: { name: 'F2P' },
    [PlayerBuild.F2P_LVL3]: { name: 'F2P & Level 3' },
    [PlayerBuild.LVL3]: { name: 'Level 3' },
    [PlayerBuild.ZERKER]: { name: 'Zerker Pure' },
    [PlayerBuild.DEF1]: { name: '1 Defence Pure' },
    [PlayerBuild.HP10]: { name: '10 Hitpoints Pure' }
};
const PlayerStatusProps = {
    [PlayerStatus.ACTIVE]: { name: 'Active' },
    [PlayerStatus.UNRANKED]: { name: 'Unranked' },
    [PlayerStatus.FLAGGED]: { name: 'Flagged' },
    [PlayerStatus.ARCHIVED]: { name: 'Archived' },
    [PlayerStatus.BANNED]: { name: 'Banned' }
};
const PLAYER_TYPES = Object.values(PlayerType);
const PLAYER_BUILDS = Object.values(PlayerBuild);
const PLAYER_STATUSES = Object.values(PlayerStatus);
function isPlayerType(typeString) {
    return typeString in PlayerTypeProps;
}
function isPlayerBuild(buildString) {
    return buildString in PlayerBuildProps;
}
function isPlayerStatus(statusString) {
    return statusString in PlayerStatusProps;
}
function findPlayerType(typeName) {
    for (const [key, value] of Object.entries(PlayerTypeProps)) {
        if (value.name.toUpperCase() === typeName.toUpperCase())
            return key;
    }
    return null;
}
function findPlayerBuild(buildName) {
    for (const [key, value] of Object.entries(PlayerBuildProps)) {
        if (value.name.toUpperCase() === buildName.toUpperCase())
            return key;
    }
    return null;
}

function formatNumber(num, withLetters = false, decimalPrecision = 2) {
    if (num === undefined || num === null)
        return -1;
    // If number is float
    if (num % 1 !== 0) {
        return (Math.round(num * 100) / 100).toLocaleString('en-US');
    }
    if ((num < 10000 && num > -10000) || !withLetters) {
        return num.toLocaleString('en-US');
    }
    // < 100k
    if (num < 100000 && num > -100000) {
        // If has no decimals, return as whole number instead (10.00k => 10k)
        if ((num / 1000) % 1 === 0)
            return `${num / 1000}k`;
        return `${(num / 1000).toFixed(decimalPrecision)}k`;
    }
    // < 10 million
    if (num < 10000000 && num > -10000000) {
        return `${Math.round(num / 1000)}k`;
    }
    // < 1 billion
    if (num < 1000000000 && num > -1000000000) {
        // If has no decimals, return as whole number instead (10.00m => 10m)
        if ((num / 1000000) % 1 === 0)
            return `${num / 1000000}m`;
        return `${(num / 1000000).toFixed(decimalPrecision)}m`;
    }
    // If has no decimals, return as whole number instead (10.00b => 10b)
    if ((num / 1000000000) % 1 === 0)
        return `${num / 1000000000}b`;
    return `${(num / 1000000000).toFixed(decimalPrecision)}b`;
}
function padNumber(value) {
    if (!value)
        return '00';
    return value < 10 ? `0${value}` : value.toString();
}
function round(num, cases) {
    return Math.round(num * Math.pow(10, cases)) / Math.pow(10, cases);
}

var EfficiencyAlgorithmType;
(function (EfficiencyAlgorithmType) {
    EfficiencyAlgorithmType["MAIN"] = "main";
    EfficiencyAlgorithmType["IRONMAN"] = "ironman";
    EfficiencyAlgorithmType["ULTIMATE"] = "ultimate";
    EfficiencyAlgorithmType["LVL3"] = "lvl3";
    EfficiencyAlgorithmType["F2P"] = "f2p";
    EfficiencyAlgorithmType["F2P_LVL3"] = "f2p_lvl3";
    EfficiencyAlgorithmType["F2P_IRONMAN"] = "f2p_ironman";
    EfficiencyAlgorithmType["F2P_LVL3_IRONMAN"] = "f2p_lvl3_ironman";
})(EfficiencyAlgorithmType || (EfficiencyAlgorithmType = {}));

class EfficiencyClient extends BaseAPIClient {
    /**
     * Fetches the current efficiency leaderboard for a specific efficiency metric, playerType, playerBuild and country.
     * @returns A list of players.
     */
    getEfficiencyLeaderboards(filter, pagination) {
        return this.getRequest('/efficiency/leaderboard', Object.assign(Object.assign({}, filter), pagination));
    }
    /**
     * Fetches the top EHP (Efficient Hours Played) rates.
     * @returns A list of skilling methods and their bonus exp ratios.
     */
    getEHPRates(algorithmType) {
        return this.getRequest('/efficiency/rates', {
            metric: Metric.EHP,
            type: algorithmType
        });
    }
    /**
     * Fetches the top EHB (Efficient Hours Bossed) rates.
     * @returns A list of bosses and their respective "per-hour" kill rates.
     */
    getEHBRates(algorithmType) {
        return this.getRequest('/efficiency/rates', {
            metric: Metric.EHB,
            type: algorithmType
        });
    }
}

class NameChangesClient extends BaseAPIClient {
    /**
     * Searches for name changes that match a name and/or status filter.
     * @returns A list of name changes.
     */
    searchNameChanges(filter, pagination) {
        return this.getRequest('/names', Object.assign(Object.assign({}, filter), pagination));
    }
    /**
     * Submits a name change request between two usernames (old and new).
     * @returns A pending name change request, to be reviewed and resolved at a later date.
     */
    submitNameChange(oldName, newName) {
        return this.postRequest('/names', { oldName, newName });
    }
}

class CompetitionsClient extends BaseAPIClient {
    /**
     * Searches for competitions that match a title, type, metric and status filter.
     * @returns A list of competitions.
     */
    searchCompetitions(filter, pagination) {
        return this.getRequest('/competitions', Object.assign(Object.assign({}, filter), pagination));
    }
    /**
     * Fetches the competition's full details, including all the participants and their progress.
     * @returns A competition with a list of participants.
     */
    getCompetitionDetails(id, previewMetric) {
        return this.getRequest(`/competitions/${id}`, { metric: previewMetric });
    }
    /**
     * Fetches the competition's participant list in CSV format.
     * @returns A string containing the CSV content.
     */
    getCompetitionDetailsCSV(id, params) {
        return this.getText(`/competitions/${id}/csv`, Object.assign({ metric: params.previewMetric }, params));
    }
    /**
     * Fetches all the values (exp, kc, etc) in chronological order within the bounds
     * of the competition, for the top 5 participants.
     * @returns A list of competition progress objects, including the player and their value history over time.
     */
    getCompetitionTopHistory(id, previewMetric) {
        return this.getRequest(`/competitions/${id}/top-history`, {
            metric: previewMetric
        });
    }
    /**
     * Creates a new competition.
     * @returns The newly created competition, and the verification code that authorizes future changes to it.
     */
    createCompetition(payload) {
        return this.postRequest('/competitions', payload);
    }
    /**
     * Edits an existing competition.
     * @returns The updated competition.
     */
    editCompetition(id, payload, verificationCode) {
        return this.putRequest(`/competitions/${id}`, Object.assign(Object.assign({}, payload), { verificationCode }));
    }
    /**
     * Deletes an existing competition.
     * @returns A confirmation message.
     */
    deleteCompetition(id, verificationCode) {
        return this.deleteRequest(`/competitions/${id}`, { verificationCode });
    }
    /**
     * Adds all (valid) given participants to a competition, ignoring duplicates.
     * @returns The number of participants added and a confirmation message.
     */
    addParticipants(id, participants, verificationCode) {
        return this.postRequest(`/competitions/${id}/participants`, {
            verificationCode,
            participants
        });
    }
    /**
     * Remove all given usernames from a competition, ignoring usernames that aren't competing.
     * @returns The number of participants removed and a confirmation message.
     */
    removeParticipants(id, participants, verificationCode) {
        return this.deleteRequest(`/competitions/${id}/participants`, {
            verificationCode,
            participants
        });
    }
    /**
     * Adds all (valid) given teams to a team competition, ignoring duplicates.
     * @returns The number of participants added and a confirmation message.
     */
    addTeams(id, teams, verificationCode) {
        return this.postRequest(`/competitions/${id}/teams`, {
            verificationCode,
            teams
        });
    }
    /**
     * Remove all given team names from a competition, ignoring names that don't exist.
     * @returns The number of participants removed and a confirmation message.
     */
    removeTeams(id, teamNames, verificationCode) {
        return this.deleteRequest(`/competitions/${id}/teams`, {
            verificationCode,
            teamNames
        });
    }
    /**
     * Adds an "update" request to the queue, for each outdated competition participant.
     * @returns The number of players to be updated and a confirmation message.
     */
    updateAll(id, verificationCode) {
        return this.postRequest(`/competitions/${id}/update-all`, {
            verificationCode
        });
    }
}

class WOMClient extends BaseAPIClient {
    constructor(options) {
        const baseApiUrl = (options === null || options === void 0 ? void 0 : options.baseAPIUrl) || config.baseAPIUrl;
        const headers = {
            'x-user-agent': (options === null || options === void 0 ? void 0 : options.userAgent) || config.defaultUserAgent
        };
        if (options === null || options === void 0 ? void 0 : options.apiKey) {
            headers['x-api-key'] = options.apiKey;
        }
        super(headers, baseApiUrl);
        this.deltas = new DeltasClient(headers, baseApiUrl);
        this.groups = new GroupsClient(headers, baseApiUrl);
        this.players = new PlayersClient(headers, baseApiUrl);
        this.records = new RecordsClient(headers, baseApiUrl);
        this.efficiency = new EfficiencyClient(headers, baseApiUrl);
        this.nameChanges = new NameChangesClient(headers, baseApiUrl);
        this.competitions = new CompetitionsClient(headers, baseApiUrl);
    }
}

export { ACTIVITIES, Activity, ActivityType, BOSSES, Boss, CAPPED_MAX_TOTAL_XP, COMBAT_SKILLS, COMPETITION_STATUSES, COMPETITION_TYPES, COMPUTED_METRICS, COUNTRY_CODES, CompetitionCSVTableType, CompetitionStatus, CompetitionStatusProps, CompetitionType, CompetitionTypeProps, ComputedMetric, Country, CountryProps, EfficiencyAlgorithmType, F2P_BOSSES, GROUP_ROLES, GroupRole, GroupRoleProps, MAX_LEVEL, MAX_SKILL_EXP, MAX_VIRTUAL_LEVEL, MEMBER_SKILLS, METRICS, Metric, MetricMeasure, MetricProps, MetricType, NameChangeStatus, PERIODS, PLAYER_BUILDS, PLAYER_STATUSES, PLAYER_TYPES, PRIVELEGED_GROUP_ROLES, Period, PeriodProps, PlayerBuild, PlayerBuildProps, PlayerStatus, PlayerStatusProps, PlayerType, PlayerTypeProps, REAL_METRICS, REAL_SKILLS, SKILLS, SKILL_EXP_AT_99, Skill, WOMClient, findCountry, findCountryByCode, findCountryByName, findGroupRole, findMetric, findPeriod, findPlayerBuild, findPlayerType, formatNumber, getCombatLevel, getExpForLevel, getLevel, getMetricMeasure, getMetricName, getMetricRankKey, getMetricValueKey, getMinimumValue, getParentEfficiencyMetric, isActivity, isBoss, isCompetitionStatus, isCompetitionType, isComputedMetric, isCountry, isGroupRole, isMetric, isPeriod, isPlayerBuild, isPlayerStatus, isPlayerType, isSkill, padNumber, parsePeriodExpression, round };
