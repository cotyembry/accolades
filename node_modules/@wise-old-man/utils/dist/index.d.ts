/**
 * Hardcode Prisma Types into this file, to avoid having to import the whole Prisma Client
 */

type Prisma_Base_Achievement = {
  playerId: number;
  name: string;
  metric: Metric;
  threshold: bigint;
  accuracy: bigint | null;
  createdAt: Date;
};

export type MemberActivity = {
  groupId: number;
  playerId: number;
  type: ActivityType;
  role: GroupRole | null;
  previousRole: GroupRole | null;
  createdAt: Date;
};

export type PlayerArchive = {
  playerId: number;
  previousUsername: string;
  archiveUsername: string;
  restoredUsername: string | null;
  createdAt: Date;
  restoredAt: Date | null;
};

type Prisma_Base_GroupSocialLinks = {
  id: number;
  groupId: number;
  website: string | null;
  discord: string | null;
  twitter: string | null;
  youtube: string | null;
  twitch: string | null;
  updatedAt: Date;
  createdAt: Date;
};

export type Membership = {
  playerId: number;
  groupId: number;
  role: GroupRole;
  createdAt: Date;
  updatedAt: Date;
};

export type Prisma_Base_Group = {
  id: number;
  name: string;
  clanChat: string | null;
  description: string | null;
  homeworld: number | null;
  verified: boolean;
  patron: boolean;
  visible: boolean;
  profileImage: string | null;
  bannerImage: string | null;
  score: number;
  verificationHash: string;
  createdAt: Date;
  updatedAt: Date;
  creatorIpHash: string | null;
};

export type GroupRoleOrder = {
  role: GroupRole;
  index: number;
};

type Participation = {
  playerId: number;
  competitionId: number;
  startSnapshotId: number | null;
  endSnapshotId: number | null;
  teamName: string | null;
  createdAt: Date;
  updatedAt: Date;
};

type Prisma_Base_Competition = {
  id: number;
  title: string;
  metric: Metric;
  type: CompetitionType;
  startsAt: Date;
  endsAt: Date;
  groupId: number | null;
  score: number;
  visible: boolean;
  verificationHash: string;
  createdAt: Date | null;
  updatedAt: Date | null;
  creatorIpHash: string | null;
};

type Prisma_Base_NameChange = {
  id: number;
  playerId: number;
  oldName: string;
  newName: string;
  status: NameChangeStatus;
  reviewContext: unknown | null;
  resolvedAt: Date | null;
  updatedAt: Date;
  createdAt: Date;
};

type Prisma_Base_Player = {
  id: number;
  username: string;
  displayName: string;
  type: PlayerType;
  build: PlayerBuild;
  status: PlayerStatus;
  country: Country | null;
  patron: boolean;
  exp: bigint;
  ehp: number;
  ehb: number;
  ttm: number;
  tt200m: number;
  registeredAt: Date;
  updatedAt: Date | null;
  lastChangedAt: Date | null;
  lastImportedAt: Date | null;
  latestSnapshotId: number | null;
};

type Prisma_Base_Record = {
  id: number;
  playerId: number;
  period: Period;
  metric: Metric;
  value: bigint;
  updatedAt: Date;
};

type Prisma_Base_Snapshot = {
  id: number;
  playerId: number;
  importedAt: Date | null;
  createdAt: Date;
  overallRank: number;
  overallExperience: bigint;
  attackRank: number;
  attackExperience: number;
  defenceRank: number;
  defenceExperience: number;
  strengthRank: number;
  strengthExperience: number;
  hitpointsRank: number;
  hitpointsExperience: number;
  rangedRank: number;
  rangedExperience: number;
  prayerRank: number;
  prayerExperience: number;
  magicRank: number;
  magicExperience: number;
  cookingRank: number;
  cookingExperience: number;
  woodcuttingRank: number;
  woodcuttingExperience: number;
  fletchingRank: number;
  fletchingExperience: number;
  fishingRank: number;
  fishingExperience: number;
  firemakingRank: number;
  firemakingExperience: number;
  craftingRank: number;
  craftingExperience: number;
  smithingRank: number;
  smithingExperience: number;
  miningRank: number;
  miningExperience: number;
  herbloreRank: number;
  herbloreExperience: number;
  agilityRank: number;
  agilityExperience: number;
  thievingRank: number;
  thievingExperience: number;
  slayerRank: number;
  slayerExperience: number;
  farmingRank: number;
  farmingExperience: number;
  runecraftingRank: number;
  runecraftingExperience: number;
  hunterRank: number;
  hunterExperience: number;
  constructionRank: number;
  constructionExperience: number;
  league_pointsRank: number;
  league_pointsScore: number;
  bounty_hunter_hunterRank: number;
  bounty_hunter_hunterScore: number;
  bounty_hunter_rogueScore: number;
  clue_scrolls_allRank: number;
  bounty_hunter_rogueRank: number;
  clue_scrolls_allScore: number;
  clue_scrolls_beginnerRank: number;
  clue_scrolls_easyRank: number;
  clue_scrolls_beginnerScore: number;
  clue_scrolls_easyScore: number;
  clue_scrolls_mediumRank: number;
  clue_scrolls_mediumScore: number;
  clue_scrolls_hardRank: number;
  clue_scrolls_hardScore: number;
  clue_scrolls_eliteRank: number;
  clue_scrolls_eliteScore: number;
  clue_scrolls_masterRank: number;
  clue_scrolls_masterScore: number;
  last_man_standingRank: number;
  last_man_standingScore: number;
  pvp_arenaRank: number;
  pvp_arenaScore: number;
  abyssal_sireRank: number;
  abyssal_sireKills: number;
  alchemical_hydraRank: number;
  alchemical_hydraKills: number;
  amoxliatlRank: number;
  amoxliatlKills: number;
  artioRank: number;
  artioKills: number;
  barrows_chestsRank: number;
  barrows_chestsKills: number;
  bryophytaKills: number;
  bryophytaRank: number;
  cerberusKills: number;
  chambers_of_xericRank: number;
  cerberusRank: number;
  callistoRank: number;
  callistoKills: number;
  calvarionRank: number;
  calvarionKills: number;
  chambers_of_xericKills: number;
  chambers_of_xeric_challenge_modeRank: number;
  chambers_of_xeric_challenge_modeKills: number;
  chaos_elementalKills: number;
  chaos_fanaticKills: number;
  chaos_fanaticRank: number;
  commander_zilyanaRank: number;
  chaos_elementalRank: number;
  commander_zilyanaKills: number;
  corporeal_beastRank: number;
  corporeal_beastKills: number;
  crazy_archaeologistRank: number;
  crazy_archaeologistKills: number;
  dagannoth_primeRank: number;
  dagannoth_primeKills: number;
  dagannoth_rexRank: number;
  dagannoth_rexKills: number;
  dagannoth_supremeRank: number;
  dagannoth_supremeKills: number;
  deranged_archaeologistRank: number;
  deranged_archaeologistKills: number;
  general_graardorRank: number;
  general_graardorKills: number;
  giant_moleRank: number;
  giant_moleKills: number;
  grotesque_guardiansRank: number;
  grotesque_guardiansKills: number;
  hesporiRank: number;
  hesporiKills: number;
  kalphite_queenKills: number;
  kalphite_queenRank: number;
  king_black_dragonRank: number;
  king_black_dragonKills: number;
  krakenRank: number;
  krakenKills: number;
  kreearraRank: number;
  kreearraKills: number;
  kril_tsutsarothRank: number;
  kril_tsutsarothKills: number;
  mimicRank: number;
  mimicKills: number;
  nightmareRank: number;
  nightmareKills: number;
  oborRank: number;
  oborKills: number;
  phantom_muspahRank: number;
  phantom_muspahKills: number;
  sarachnisRank: number;
  sarachnisKills: number;
  scorpiaRank: number;
  scorpiaKills: number;
  skotizoRank: number;
  skotizoKills: number;
  spindelRank: number;
  spindelKills: number;
  the_gauntletRank: number;
  the_gauntletKills: number;
  the_corrupted_gauntletKills: number;
  the_corrupted_gauntletRank: number;
  the_hueycoatlRank: number;
  the_hueycoatlKills: number;
  theatre_of_bloodRank: number;
  theatre_of_bloodKills: number;
  thermonuclear_smoke_devilRank: number;
  thermonuclear_smoke_devilKills: number;
  tombs_of_amascutRank: number;
  tombs_of_amascutKills: number;
  tombs_of_amascut_expertRank: number;
  tombs_of_amascut_expertKills: number;
  tzkal_zukRank: number;
  tzkal_zukKills: number;
  tztok_jadRank: number;
  tztok_jadKills: number;
  venenatisRank: number;
  venenatisKills: number;
  vetionRank: number;
  vetionKills: number;
  vorkathRank: number;
  vorkathKills: number;
  wintertodtRank: number;
  zalcanoRank: number;
  wintertodtKills: number;
  zalcanoKills: number;
  zulrahRank: number;
  zulrahKills: number;
  ehpValue: number;
  ehbValue: number;
  ehbRank: number;
  ehpRank: number;
  soul_wars_zealScore: number;
  soul_wars_zealRank: number;
  temporossKills: number;
  temporossRank: number;
  theatre_of_blood_hard_modeKills: number;
  theatre_of_blood_hard_modeRank: number;
  phosanis_nightmareKills: number;
  phosanis_nightmareRank: number;
  nexKills: number;
  nexRank: number;
  guardians_of_the_riftScore: number;
  guardians_of_the_riftRank: number;
};


/**
 * Prisma currently seems to ignore the @map() in enum declarations.
 *
 * So by declaring this enum in the schema file:
 *
 * enum NameChangeStatus {
 *    PENDING     @map('pending')
 *    DENIED      @map('denied')
 *    APPROVED    @map('approved')
 * }
 *
 * you would expect the prisma client to then generate the following object:
 *
 * const NameChangeStatus = {
 *    PENDING: 'pending',
 *    DENIED: 'denied',
 *    APPROVED: 'approved',
 * }
 *
 * but unfortunately, the mapping is only used for queries, and the actual esulting object is this:
 *
 * const NameChangeStatus = {
 *    PENDING: 'PENDING',
 *    DENIED: 'DENIED',
 *    APPROVED: 'APPROVED',
 * }
 *
 * And because I'd hate having to call enum values in lowercase, like:
 *    NameChangeStatus.pending
 *    Metric.king_black_dragon
 *    Period.day
 *
 * I'd rather do some mapping to ensure I have the best of both worlds,
 * lowercase database values, but with uppercase in code.
 * With the mappings below, we can now use prisma enums by calling them with uppercase, like:
 *
 *    NameChangeStatus.PENDING
 *    Metric.KING_BLACK_DRAGON
 *    Period.DAY
 *
 */
declare const Skill: {
    readonly OVERALL: "overall";
    readonly ATTACK: "attack";
    readonly DEFENCE: "defence";
    readonly STRENGTH: "strength";
    readonly HITPOINTS: "hitpoints";
    readonly RANGED: "ranged";
    readonly PRAYER: "prayer";
    readonly MAGIC: "magic";
    readonly COOKING: "cooking";
    readonly WOODCUTTING: "woodcutting";
    readonly FLETCHING: "fletching";
    readonly FISHING: "fishing";
    readonly FIREMAKING: "firemaking";
    readonly CRAFTING: "crafting";
    readonly SMITHING: "smithing";
    readonly MINING: "mining";
    readonly HERBLORE: "herblore";
    readonly AGILITY: "agility";
    readonly THIEVING: "thieving";
    readonly SLAYER: "slayer";
    readonly FARMING: "farming";
    readonly RUNECRAFTING: "runecrafting";
    readonly HUNTER: "hunter";
    readonly CONSTRUCTION: "construction";
};
type Skill = (typeof Skill)[keyof typeof Skill];
declare const Activity: {
    readonly LEAGUE_POINTS: "league_points";
    readonly BOUNTY_HUNTER_HUNTER: "bounty_hunter_hunter";
    readonly BOUNTY_HUNTER_ROGUE: "bounty_hunter_rogue";
    readonly CLUE_SCROLLS_ALL: "clue_scrolls_all";
    readonly CLUE_SCROLLS_BEGINNER: "clue_scrolls_beginner";
    readonly CLUE_SCROLLS_EASY: "clue_scrolls_easy";
    readonly CLUE_SCROLLS_MEDIUM: "clue_scrolls_medium";
    readonly CLUE_SCROLLS_HARD: "clue_scrolls_hard";
    readonly CLUE_SCROLLS_ELITE: "clue_scrolls_elite";
    readonly CLUE_SCROLLS_MASTER: "clue_scrolls_master";
    readonly LAST_MAN_STANDING: "last_man_standing";
    readonly PVP_ARENA: "pvp_arena";
    readonly SOUL_WARS_ZEAL: "soul_wars_zeal";
    readonly GUARDIANS_OF_THE_RIFT: "guardians_of_the_rift";
    readonly COLOSSEUM_GLORY: "colosseum_glory";
};
type Activity = (typeof Activity)[keyof typeof Activity];
declare const Boss: {
    readonly ABYSSAL_SIRE: "abyssal_sire";
    readonly ALCHEMICAL_HYDRA: "alchemical_hydra";
    readonly AMOXLIATL: "amoxliatl";
    readonly ARAXXOR: "araxxor";
    readonly ARTIO: "artio";
    readonly BARROWS_CHESTS: "barrows_chests";
    readonly BRYOPHYTA: "bryophyta";
    readonly CALLISTO: "callisto";
    readonly CALVARION: "calvarion";
    readonly CERBERUS: "cerberus";
    readonly CHAMBERS_OF_XERIC: "chambers_of_xeric";
    readonly CHAMBERS_OF_XERIC_CM: "chambers_of_xeric_challenge_mode";
    readonly CHAOS_ELEMENTAL: "chaos_elemental";
    readonly CHAOS_FANATIC: "chaos_fanatic";
    readonly COMMANDER_ZILYANA: "commander_zilyana";
    readonly CORPOREAL_BEAST: "corporeal_beast";
    readonly CRAZY_ARCHAEOLOGIST: "crazy_archaeologist";
    readonly DAGANNOTH_PRIME: "dagannoth_prime";
    readonly DAGANNOTH_REX: "dagannoth_rex";
    readonly DAGANNOTH_SUPREME: "dagannoth_supreme";
    readonly DERANGED_ARCHAEOLOGIST: "deranged_archaeologist";
    readonly DUKE_SUCELLUS: "duke_sucellus";
    readonly GENERAL_GRAARDOR: "general_graardor";
    readonly GIANT_MOLE: "giant_mole";
    readonly GROTESQUE_GUARDIANS: "grotesque_guardians";
    readonly HESPORI: "hespori";
    readonly KALPHITE_QUEEN: "kalphite_queen";
    readonly KING_BLACK_DRAGON: "king_black_dragon";
    readonly KRAKEN: "kraken";
    readonly KREEARRA: "kreearra";
    readonly KRIL_TSUTSAROTH: "kril_tsutsaroth";
    readonly LUNAR_CHESTS: "lunar_chests";
    readonly MIMIC: "mimic";
    readonly NEX: "nex";
    readonly NIGHTMARE: "nightmare";
    readonly PHOSANIS_NIGHTMARE: "phosanis_nightmare";
    readonly OBOR: "obor";
    readonly PHANTOM_MUSPAH: "phantom_muspah";
    readonly SARACHNIS: "sarachnis";
    readonly SCORPIA: "scorpia";
    readonly SCURRIUS: "scurrius";
    readonly SKOTIZO: "skotizo";
    readonly SOL_HEREDIT: "sol_heredit";
    readonly SPINDEL: "spindel";
    readonly TEMPOROSS: "tempoross";
    readonly THE_GAUNTLET: "the_gauntlet";
    readonly THE_CORRUPTED_GAUNTLET: "the_corrupted_gauntlet";
    readonly THE_HUEYCOATL: "the_hueycoatl";
    readonly THE_LEVIATHAN: "the_leviathan";
    readonly THE_WHISPERER: "the_whisperer";
    readonly THEATRE_OF_BLOOD: "theatre_of_blood";
    readonly THEATRE_OF_BLOOD_HARD_MODE: "theatre_of_blood_hard_mode";
    readonly THERMONUCLEAR_SMOKE_DEVIL: "thermonuclear_smoke_devil";
    readonly TOMBS_OF_AMASCUT: "tombs_of_amascut";
    readonly TOMBS_OF_AMASCUT_EXPERT: "tombs_of_amascut_expert";
    readonly TZKAL_ZUK: "tzkal_zuk";
    readonly TZTOK_JAD: "tztok_jad";
    readonly VARDORVIS: "vardorvis";
    readonly VENENATIS: "venenatis";
    readonly VETION: "vetion";
    readonly VORKATH: "vorkath";
    readonly WINTERTODT: "wintertodt";
    readonly ZALCANO: "zalcano";
    readonly ZULRAH: "zulrah";
};
type Boss = (typeof Boss)[keyof typeof Boss];
declare const ComputedMetric: {
    readonly EHP: "ehp";
    readonly EHB: "ehb";
};
type ComputedMetric = (typeof ComputedMetric)[keyof typeof ComputedMetric];
declare const Metric: {
    readonly EHP: "ehp";
    readonly EHB: "ehb";
    readonly ABYSSAL_SIRE: "abyssal_sire";
    readonly ALCHEMICAL_HYDRA: "alchemical_hydra";
    readonly AMOXLIATL: "amoxliatl";
    readonly ARAXXOR: "araxxor";
    readonly ARTIO: "artio";
    readonly BARROWS_CHESTS: "barrows_chests";
    readonly BRYOPHYTA: "bryophyta";
    readonly CALLISTO: "callisto";
    readonly CALVARION: "calvarion";
    readonly CERBERUS: "cerberus";
    readonly CHAMBERS_OF_XERIC: "chambers_of_xeric";
    readonly CHAMBERS_OF_XERIC_CM: "chambers_of_xeric_challenge_mode";
    readonly CHAOS_ELEMENTAL: "chaos_elemental";
    readonly CHAOS_FANATIC: "chaos_fanatic";
    readonly COMMANDER_ZILYANA: "commander_zilyana";
    readonly CORPOREAL_BEAST: "corporeal_beast";
    readonly CRAZY_ARCHAEOLOGIST: "crazy_archaeologist";
    readonly DAGANNOTH_PRIME: "dagannoth_prime";
    readonly DAGANNOTH_REX: "dagannoth_rex";
    readonly DAGANNOTH_SUPREME: "dagannoth_supreme";
    readonly DERANGED_ARCHAEOLOGIST: "deranged_archaeologist";
    readonly DUKE_SUCELLUS: "duke_sucellus";
    readonly GENERAL_GRAARDOR: "general_graardor";
    readonly GIANT_MOLE: "giant_mole";
    readonly GROTESQUE_GUARDIANS: "grotesque_guardians";
    readonly HESPORI: "hespori";
    readonly KALPHITE_QUEEN: "kalphite_queen";
    readonly KING_BLACK_DRAGON: "king_black_dragon";
    readonly KRAKEN: "kraken";
    readonly KREEARRA: "kreearra";
    readonly KRIL_TSUTSAROTH: "kril_tsutsaroth";
    readonly LUNAR_CHESTS: "lunar_chests";
    readonly MIMIC: "mimic";
    readonly NEX: "nex";
    readonly NIGHTMARE: "nightmare";
    readonly PHOSANIS_NIGHTMARE: "phosanis_nightmare";
    readonly OBOR: "obor";
    readonly PHANTOM_MUSPAH: "phantom_muspah";
    readonly SARACHNIS: "sarachnis";
    readonly SCORPIA: "scorpia";
    readonly SCURRIUS: "scurrius";
    readonly SKOTIZO: "skotizo";
    readonly SOL_HEREDIT: "sol_heredit";
    readonly SPINDEL: "spindel";
    readonly TEMPOROSS: "tempoross";
    readonly THE_GAUNTLET: "the_gauntlet";
    readonly THE_CORRUPTED_GAUNTLET: "the_corrupted_gauntlet";
    readonly THE_HUEYCOATL: "the_hueycoatl";
    readonly THE_LEVIATHAN: "the_leviathan";
    readonly THE_WHISPERER: "the_whisperer";
    readonly THEATRE_OF_BLOOD: "theatre_of_blood";
    readonly THEATRE_OF_BLOOD_HARD_MODE: "theatre_of_blood_hard_mode";
    readonly THERMONUCLEAR_SMOKE_DEVIL: "thermonuclear_smoke_devil";
    readonly TOMBS_OF_AMASCUT: "tombs_of_amascut";
    readonly TOMBS_OF_AMASCUT_EXPERT: "tombs_of_amascut_expert";
    readonly TZKAL_ZUK: "tzkal_zuk";
    readonly TZTOK_JAD: "tztok_jad";
    readonly VARDORVIS: "vardorvis";
    readonly VENENATIS: "venenatis";
    readonly VETION: "vetion";
    readonly VORKATH: "vorkath";
    readonly WINTERTODT: "wintertodt";
    readonly ZALCANO: "zalcano";
    readonly ZULRAH: "zulrah";
    readonly LEAGUE_POINTS: "league_points";
    readonly BOUNTY_HUNTER_HUNTER: "bounty_hunter_hunter";
    readonly BOUNTY_HUNTER_ROGUE: "bounty_hunter_rogue";
    readonly CLUE_SCROLLS_ALL: "clue_scrolls_all";
    readonly CLUE_SCROLLS_BEGINNER: "clue_scrolls_beginner";
    readonly CLUE_SCROLLS_EASY: "clue_scrolls_easy";
    readonly CLUE_SCROLLS_MEDIUM: "clue_scrolls_medium";
    readonly CLUE_SCROLLS_HARD: "clue_scrolls_hard";
    readonly CLUE_SCROLLS_ELITE: "clue_scrolls_elite";
    readonly CLUE_SCROLLS_MASTER: "clue_scrolls_master";
    readonly LAST_MAN_STANDING: "last_man_standing";
    readonly PVP_ARENA: "pvp_arena";
    readonly SOUL_WARS_ZEAL: "soul_wars_zeal";
    readonly GUARDIANS_OF_THE_RIFT: "guardians_of_the_rift";
    readonly COLOSSEUM_GLORY: "colosseum_glory";
    readonly OVERALL: "overall";
    readonly ATTACK: "attack";
    readonly DEFENCE: "defence";
    readonly STRENGTH: "strength";
    readonly HITPOINTS: "hitpoints";
    readonly RANGED: "ranged";
    readonly PRAYER: "prayer";
    readonly MAGIC: "magic";
    readonly COOKING: "cooking";
    readonly WOODCUTTING: "woodcutting";
    readonly FLETCHING: "fletching";
    readonly FISHING: "fishing";
    readonly FIREMAKING: "firemaking";
    readonly CRAFTING: "crafting";
    readonly SMITHING: "smithing";
    readonly MINING: "mining";
    readonly HERBLORE: "herblore";
    readonly AGILITY: "agility";
    readonly THIEVING: "thieving";
    readonly SLAYER: "slayer";
    readonly FARMING: "farming";
    readonly RUNECRAFTING: "runecrafting";
    readonly HUNTER: "hunter";
    readonly CONSTRUCTION: "construction";
};
type Metric = (typeof Metric)[keyof typeof Metric];
declare const NameChangeStatus: {
    readonly PENDING: "pending";
    readonly DENIED: "denied";
    readonly APPROVED: "approved";
};
type NameChangeStatus = (typeof NameChangeStatus)[keyof typeof NameChangeStatus];
declare const Period: {
    readonly FIVE_MIN: "five_min";
    readonly DAY: "day";
    readonly WEEK: "week";
    readonly MONTH: "month";
    readonly YEAR: "year";
};
type Period = (typeof Period)[keyof typeof Period];
declare const PlayerType: {
    readonly UNKNOWN: "unknown";
    readonly REGULAR: "regular";
    readonly IRONMAN: "ironman";
    readonly HARDCORE: "hardcore";
    readonly ULTIMATE: "ultimate";
};
type PlayerType = (typeof PlayerType)[keyof typeof PlayerType];
declare const PlayerBuild: {
    readonly MAIN: "main";
    readonly F2P: "f2p";
    readonly F2P_LVL3: "f2p_lvl3";
    readonly LVL3: "lvl3";
    readonly ZERKER: "zerker";
    readonly DEF1: "def1";
    readonly HP10: "hp10";
};
type PlayerBuild = (typeof PlayerBuild)[keyof typeof PlayerBuild];
declare const PlayerStatus: {
    readonly ACTIVE: "active";
    readonly UNRANKED: "unranked";
    readonly FLAGGED: "flagged";
    readonly ARCHIVED: "archived";
    readonly BANNED: "banned";
};
type PlayerStatus = (typeof PlayerStatus)[keyof typeof PlayerStatus];
declare const CompetitionType: {
    readonly CLASSIC: "classic";
    readonly TEAM: "team";
};
type CompetitionType = (typeof CompetitionType)[keyof typeof CompetitionType];
declare const GroupRole: {
    readonly ACHIEVER: "achiever";
    readonly ADAMANT: "adamant";
    readonly ADEPT: "adept";
    readonly ADMINISTRATOR: "administrator";
    readonly ADMIRAL: "admiral";
    readonly ADVENTURER: "adventurer";
    readonly AIR: "air";
    readonly ANCHOR: "anchor";
    readonly APOTHECARY: "apothecary";
    readonly ARCHER: "archer";
    readonly ARMADYLEAN: "armadylean";
    readonly ARTILLERY: "artillery";
    readonly ARTISAN: "artisan";
    readonly ASGARNIAN: "asgarnian";
    readonly ASSASSIN: "assassin";
    readonly ASSISTANT: "assistant";
    readonly ASTRAL: "astral";
    readonly ATHLETE: "athlete";
    readonly ATTACKER: "attacker";
    readonly BANDIT: "bandit";
    readonly BANDOSIAN: "bandosian";
    readonly BARBARIAN: "barbarian";
    readonly BATTLEMAGE: "battlemage";
    readonly BEAST: "beast";
    readonly BERSERKER: "berserker";
    readonly BLISTERWOOD: "blisterwood";
    readonly BLOOD: "blood";
    readonly BLUE: "blue";
    readonly BOB: "bob";
    readonly BODY: "body";
    readonly BRASSICAN: "brassican";
    readonly BRAWLER: "brawler";
    readonly BRIGADIER: "brigadier";
    readonly BRIGAND: "brigand";
    readonly BRONZE: "bronze";
    readonly BRUISER: "bruiser";
    readonly BULWARK: "bulwark";
    readonly BURGLAR: "burglar";
    readonly BURNT: "burnt";
    readonly CADET: "cadet";
    readonly CAPTAIN: "captain";
    readonly CARRY: "carry";
    readonly CHAMPION: "champion";
    readonly CHAOS: "chaos";
    readonly CLERIC: "cleric";
    readonly COLLECTOR: "collector";
    readonly COLONEL: "colonel";
    readonly COMMANDER: "commander";
    readonly COMPETITOR: "competitor";
    readonly COMPLETIONIST: "completionist";
    readonly CONSTRUCTOR: "constructor";
    readonly COOK: "cook";
    readonly COORDINATOR: "coordinator";
    readonly CORPORAL: "corporal";
    readonly COSMIC: "cosmic";
    readonly COUNCILLOR: "councillor";
    readonly CRAFTER: "crafter";
    readonly CREW: "crew";
    readonly CRUSADER: "crusader";
    readonly CUTPURSE: "cutpurse";
    readonly DEATH: "death";
    readonly DEFENDER: "defender";
    readonly DEFILER: "defiler";
    readonly DEPUTY_OWNER: "deputy_owner";
    readonly DESTROYER: "destroyer";
    readonly DIAMOND: "diamond";
    readonly DISEASED: "diseased";
    readonly DOCTOR: "doctor";
    readonly DOGSBODY: "dogsbody";
    readonly DRAGON: "dragon";
    readonly DRAGONSTONE: "dragonstone";
    readonly DRUID: "druid";
    readonly DUELLIST: "duellist";
    readonly EARTH: "earth";
    readonly ELITE: "elite";
    readonly EMERALD: "emerald";
    readonly ENFORCER: "enforcer";
    readonly EPIC: "epic";
    readonly EXECUTIVE: "executive";
    readonly EXPERT: "expert";
    readonly EXPLORER: "explorer";
    readonly FARMER: "farmer";
    readonly FEEDER: "feeder";
    readonly FIGHTER: "fighter";
    readonly FIRE: "fire";
    readonly FIREMAKER: "firemaker";
    readonly FIRESTARTER: "firestarter";
    readonly FISHER: "fisher";
    readonly FLETCHER: "fletcher";
    readonly FORAGER: "forager";
    readonly FREMENNIK: "fremennik";
    readonly GAMER: "gamer";
    readonly GATHERER: "gatherer";
    readonly GENERAL: "general";
    readonly GNOME_CHILD: "gnome_child";
    readonly GNOME_ELDER: "gnome_elder";
    readonly GOBLIN: "goblin";
    readonly GOLD: "gold";
    readonly GOON: "goon";
    readonly GREEN: "green";
    readonly GREY: "grey";
    readonly GUARDIAN: "guardian";
    readonly GUTHIXIAN: "guthixian";
    readonly HARPOON: "harpoon";
    readonly HEALER: "healer";
    readonly HELLCAT: "hellcat";
    readonly HELPER: "helper";
    readonly HERBOLOGIST: "herbologist";
    readonly HERO: "hero";
    readonly HOLY: "holy";
    readonly HOARDER: "hoarder";
    readonly HUNTER: "hunter";
    readonly IGNITOR: "ignitor";
    readonly ILLUSIONIST: "illusionist";
    readonly IMP: "imp";
    readonly INFANTRY: "infantry";
    readonly INQUISITOR: "inquisitor";
    readonly IRON: "iron";
    readonly JADE: "jade";
    readonly JUSTICIAR: "justiciar";
    readonly KANDARIN: "kandarin";
    readonly KARAMJAN: "karamjan";
    readonly KHARIDIAN: "kharidian";
    readonly KITTEN: "kitten";
    readonly KNIGHT: "knight";
    readonly LABOURER: "labourer";
    readonly LAW: "law";
    readonly LEADER: "leader";
    readonly LEARNER: "learner";
    readonly LEGACY: "legacy";
    readonly LEGEND: "legend";
    readonly LEGIONNAIRE: "legionnaire";
    readonly LIEUTENANT: "lieutenant";
    readonly LOOTER: "looter";
    readonly LUMBERJACK: "lumberjack";
    readonly MAGIC: "magic";
    readonly MAGICIAN: "magician";
    readonly MAJOR: "major";
    readonly MAPLE: "maple";
    readonly MARSHAL: "marshal";
    readonly MASTER: "master";
    readonly MAXED: "maxed";
    readonly MEDIATOR: "mediator";
    readonly MEDIC: "medic";
    readonly MENTOR: "mentor";
    readonly MEMBER: "member";
    readonly MERCHANT: "merchant";
    readonly MIND: "mind";
    readonly MINER: "miner";
    readonly MINION: "minion";
    readonly MISTHALINIAN: "misthalinian";
    readonly MITHRIL: "mithril";
    readonly MODERATOR: "moderator";
    readonly MONARCH: "monarch";
    readonly MORYTANIAN: "morytanian";
    readonly MYSTIC: "mystic";
    readonly MYTH: "myth";
    readonly NATURAL: "natural";
    readonly NATURE: "nature";
    readonly NECROMANCER: "necromancer";
    readonly NINJA: "ninja";
    readonly NOBLE: "noble";
    readonly NOVICE: "novice";
    readonly NURSE: "nurse";
    readonly OAK: "oak";
    readonly OFFICER: "officer";
    readonly ONYX: "onyx";
    readonly OPAL: "opal";
    readonly ORACLE: "oracle";
    readonly ORANGE: "orange";
    readonly OWNER: "owner";
    readonly PAGE: "page";
    readonly PALADIN: "paladin";
    readonly PAWN: "pawn";
    readonly PILGRIM: "pilgrim";
    readonly PINE: "pine";
    readonly PINK: "pink";
    readonly PREFECT: "prefect";
    readonly PRIEST: "priest";
    readonly PRIVATE: "private";
    readonly PRODIGY: "prodigy";
    readonly PROSELYTE: "proselyte";
    readonly PROSPECTOR: "prospector";
    readonly PROTECTOR: "protector";
    readonly PURE: "pure";
    readonly PURPLE: "purple";
    readonly PYROMANCER: "pyromancer";
    readonly QUESTER: "quester";
    readonly RACER: "racer";
    readonly RAIDER: "raider";
    readonly RANGER: "ranger";
    readonly RECORD_CHASER: "record_chaser";
    readonly RECRUIT: "recruit";
    readonly RECRUITER: "recruiter";
    readonly RED_TOPAZ: "red_topaz";
    readonly RED: "red";
    readonly ROGUE: "rogue";
    readonly RUBY: "ruby";
    readonly RUNE: "rune";
    readonly RUNECRAFTER: "runecrafter";
    readonly SAGE: "sage";
    readonly SAPPHIRE: "sapphire";
    readonly SARADOMINIST: "saradominist";
    readonly SAVIOUR: "saviour";
    readonly SCAVENGER: "scavenger";
    readonly SCHOLAR: "scholar";
    readonly SCOURGE: "scourge";
    readonly SCOUT: "scout";
    readonly SCRIBE: "scribe";
    readonly SEER: "seer";
    readonly SENATOR: "senator";
    readonly SENTRY: "sentry";
    readonly SERENIST: "serenist";
    readonly SERGEANT: "sergeant";
    readonly SHAMAN: "shaman";
    readonly SHERIFF: "sheriff";
    readonly SHORT_GREEN_GUY: "short_green_guy";
    readonly SKILLER: "skiller";
    readonly SKULLED: "skulled";
    readonly SLAYER: "slayer";
    readonly SMITER: "smiter";
    readonly SMITH: "smith";
    readonly SMUGGLER: "smuggler";
    readonly SNIPER: "sniper";
    readonly SOUL: "soul";
    readonly SPECIALIST: "specialist";
    readonly SPEED_RUNNER: "speed_runner";
    readonly SPELLCASTER: "spellcaster";
    readonly SQUIRE: "squire";
    readonly STAFF: "staff";
    readonly STEEL: "steel";
    readonly STRIDER: "strider";
    readonly STRIKER: "striker";
    readonly SUMMONER: "summoner";
    readonly SUPERIOR: "superior";
    readonly SUPERVISOR: "supervisor";
    readonly TEACHER: "teacher";
    readonly TEMPLAR: "templar";
    readonly THERAPIST: "therapist";
    readonly THIEF: "thief";
    readonly TIRANNIAN: "tirannian";
    readonly TRIALIST: "trialist";
    readonly TRICKSTER: "trickster";
    readonly TZKAL: "tzkal";
    readonly TZTOK: "tztok";
    readonly UNHOLY: "unholy";
    readonly VAGRANT: "vagrant";
    readonly VANGUARD: "vanguard";
    readonly WALKER: "walker";
    readonly WANDERER: "wanderer";
    readonly WARDEN: "warden";
    readonly WARLOCK: "warlock";
    readonly WARRIOR: "warrior";
    readonly WATER: "water";
    readonly WILD: "wild";
    readonly WILLOW: "willow";
    readonly WILY: "wily";
    readonly WINTUMBER: "wintumber";
    readonly WITCH: "witch";
    readonly WIZARD: "wizard";
    readonly WORKER: "worker";
    readonly WRATH: "wrath";
    readonly XERICIAN: "xerician";
    readonly YELLOW: "yellow";
    readonly YEW: "yew";
    readonly ZAMORAKIAN: "zamorakian";
    readonly ZAROSIAN: "zarosian";
    readonly ZEALOT: "zealot";
    readonly ZENYTE: "zenyte";
};
type GroupRole = (typeof GroupRole)[keyof typeof GroupRole];
declare const Country: {
    readonly AD: "AD";
    readonly AE: "AE";
    readonly AF: "AF";
    readonly AG: "AG";
    readonly AI: "AI";
    readonly AL: "AL";
    readonly AM: "AM";
    readonly AO: "AO";
    readonly AQ: "AQ";
    readonly AR: "AR";
    readonly AS: "AS";
    readonly AT: "AT";
    readonly AU: "AU";
    readonly AW: "AW";
    readonly AX: "AX";
    readonly AZ: "AZ";
    readonly BA: "BA";
    readonly BB: "BB";
    readonly BD: "BD";
    readonly BE: "BE";
    readonly BF: "BF";
    readonly BG: "BG";
    readonly BH: "BH";
    readonly BI: "BI";
    readonly BJ: "BJ";
    readonly BL: "BL";
    readonly BM: "BM";
    readonly BN: "BN";
    readonly BO: "BO";
    readonly BQ: "BQ";
    readonly BR: "BR";
    readonly BS: "BS";
    readonly BT: "BT";
    readonly BV: "BV";
    readonly BW: "BW";
    readonly BY: "BY";
    readonly BZ: "BZ";
    readonly CA: "CA";
    readonly CC: "CC";
    readonly CD: "CD";
    readonly CF: "CF";
    readonly CG: "CG";
    readonly CH: "CH";
    readonly CI: "CI";
    readonly CK: "CK";
    readonly CL: "CL";
    readonly CM: "CM";
    readonly CN: "CN";
    readonly CO: "CO";
    readonly CR: "CR";
    readonly CU: "CU";
    readonly CV: "CV";
    readonly CW: "CW";
    readonly CX: "CX";
    readonly CY: "CY";
    readonly CZ: "CZ";
    readonly DE: "DE";
    readonly DJ: "DJ";
    readonly DK: "DK";
    readonly DM: "DM";
    readonly DO: "DO";
    readonly DZ: "DZ";
    readonly EC: "EC";
    readonly EE: "EE";
    readonly EG: "EG";
    readonly EH: "EH";
    readonly ER: "ER";
    readonly ES: "ES";
    readonly ET: "ET";
    readonly FI: "FI";
    readonly FJ: "FJ";
    readonly FK: "FK";
    readonly FM: "FM";
    readonly FO: "FO";
    readonly FR: "FR";
    readonly GA: "GA";
    readonly GB: "GB";
    readonly GB_NIR: "GB_NIR";
    readonly GB_SCT: "GB_SCT";
    readonly GB_WLS: "GB_WLS";
    readonly GD: "GD";
    readonly GE: "GE";
    readonly GF: "GF";
    readonly GG: "GG";
    readonly GH: "GH";
    readonly GI: "GI";
    readonly GL: "GL";
    readonly GM: "GM";
    readonly GN: "GN";
    readonly GP: "GP";
    readonly GQ: "GQ";
    readonly GR: "GR";
    readonly GS: "GS";
    readonly GT: "GT";
    readonly GU: "GU";
    readonly GW: "GW";
    readonly GY: "GY";
    readonly HK: "HK";
    readonly HM: "HM";
    readonly HN: "HN";
    readonly HR: "HR";
    readonly HT: "HT";
    readonly HU: "HU";
    readonly ID: "ID";
    readonly IE: "IE";
    readonly IL: "IL";
    readonly IM: "IM";
    readonly IN: "IN";
    readonly IO: "IO";
    readonly IQ: "IQ";
    readonly IR: "IR";
    readonly IS: "IS";
    readonly IT: "IT";
    readonly JE: "JE";
    readonly JM: "JM";
    readonly JO: "JO";
    readonly JP: "JP";
    readonly KE: "KE";
    readonly KG: "KG";
    readonly KH: "KH";
    readonly KI: "KI";
    readonly KM: "KM";
    readonly KN: "KN";
    readonly KP: "KP";
    readonly KR: "KR";
    readonly KW: "KW";
    readonly KY: "KY";
    readonly KZ: "KZ";
    readonly LA: "LA";
    readonly LB: "LB";
    readonly LC: "LC";
    readonly LI: "LI";
    readonly LK: "LK";
    readonly LR: "LR";
    readonly LS: "LS";
    readonly LT: "LT";
    readonly LU: "LU";
    readonly LV: "LV";
    readonly LY: "LY";
    readonly MA: "MA";
    readonly MC: "MC";
    readonly MD: "MD";
    readonly ME: "ME";
    readonly MF: "MF";
    readonly MG: "MG";
    readonly MH: "MH";
    readonly MK: "MK";
    readonly ML: "ML";
    readonly MM: "MM";
    readonly MN: "MN";
    readonly MO: "MO";
    readonly MP: "MP";
    readonly MQ: "MQ";
    readonly MR: "MR";
    readonly MS: "MS";
    readonly MT: "MT";
    readonly MU: "MU";
    readonly MV: "MV";
    readonly MW: "MW";
    readonly MX: "MX";
    readonly MY: "MY";
    readonly MZ: "MZ";
    readonly NA: "NA";
    readonly NC: "NC";
    readonly NE: "NE";
    readonly NF: "NF";
    readonly NG: "NG";
    readonly NI: "NI";
    readonly NL: "NL";
    readonly NO: "NO";
    readonly NP: "NP";
    readonly NR: "NR";
    readonly NU: "NU";
    readonly NZ: "NZ";
    readonly OM: "OM";
    readonly PA: "PA";
    readonly PE: "PE";
    readonly PF: "PF";
    readonly PG: "PG";
    readonly PH: "PH";
    readonly PK: "PK";
    readonly PL: "PL";
    readonly PM: "PM";
    readonly PN: "PN";
    readonly PR: "PR";
    readonly PS: "PS";
    readonly PT: "PT";
    readonly PW: "PW";
    readonly PY: "PY";
    readonly QA: "QA";
    readonly RE: "RE";
    readonly RO: "RO";
    readonly RS: "RS";
    readonly RU: "RU";
    readonly RW: "RW";
    readonly SA: "SA";
    readonly SB: "SB";
    readonly SC: "SC";
    readonly SD: "SD";
    readonly SE: "SE";
    readonly SG: "SG";
    readonly SH: "SH";
    readonly SI: "SI";
    readonly SJ: "SJ";
    readonly SK: "SK";
    readonly SL: "SL";
    readonly SM: "SM";
    readonly SN: "SN";
    readonly SO: "SO";
    readonly SR: "SR";
    readonly SS: "SS";
    readonly ST: "ST";
    readonly SV: "SV";
    readonly SX: "SX";
    readonly SY: "SY";
    readonly SZ: "SZ";
    readonly TC: "TC";
    readonly TD: "TD";
    readonly TF: "TF";
    readonly TG: "TG";
    readonly TH: "TH";
    readonly TJ: "TJ";
    readonly TK: "TK";
    readonly TL: "TL";
    readonly TM: "TM";
    readonly TN: "TN";
    readonly TO: "TO";
    readonly TR: "TR";
    readonly TT: "TT";
    readonly TV: "TV";
    readonly TW: "TW";
    readonly TZ: "TZ";
    readonly UA: "UA";
    readonly UG: "UG";
    readonly UM: "UM";
    readonly US: "US";
    readonly UY: "UY";
    readonly UZ: "UZ";
    readonly VA: "VA";
    readonly VC: "VC";
    readonly VE: "VE";
    readonly VG: "VG";
    readonly VI: "VI";
    readonly VN: "VN";
    readonly VU: "VU";
    readonly WF: "WF";
    readonly WS: "WS";
    readonly YE: "YE";
    readonly YT: "YT";
    readonly ZA: "ZA";
    readonly ZM: "ZM";
    readonly ZW: "ZW";
};
type Country = (typeof Country)[keyof typeof Country];
declare const ActivityType: {
    readonly JOINED: "joined";
    readonly LEFT: "left";
    readonly CHANGED_ROLE: "changed_role";
};
type ActivityType = (typeof ActivityType)[keyof typeof ActivityType];

type Achievement = Omit<Prisma_Base_Achievement, 'threshold' | 'accuracy'> & {
    threshold: number;
    accuracy: number | null;
};
type Record = Omit<Prisma_Base_Record, 'value'> & {
    value: number;
};
type Snapshot = Omit<Prisma_Base_Snapshot, 'overallExperience'> & {
    overallExperience: number;
};
type Player = Omit<Prisma_Base_Player, 'exp' | 'latestSnapshotId'> & {
    exp: number;
};
type Group = Omit<Prisma_Base_Group, 'creatorIpHash'>;
type Competition = Omit<Prisma_Base_Competition, 'creatorIpHash'>;
type NameChange = Omit<Prisma_Base_NameChange, 'reviewContext'> & {
    reviewContext: SkipContext | DenyContext | null;
};
type GroupSocialLinks = Omit<Prisma_Base_GroupSocialLinks, 'id' | 'groupId' | 'createdAt' | 'updatedAt'>;

interface AchievementTemplate {
    name: string;
    metric: Metric;
    measure?: string;
    thresholds: number[];
    getCurrentValue?: (snapshot: Snapshot, threshold: number) => number;
}
interface AchievementDefinition {
    name: string;
    metric: Metric;
    measure: string;
    threshold: number;
    validate: (snapshot: Snapshot) => boolean;
    getCurrentValue: (snapshot: Snapshot) => number;
}
interface ExtendedAchievement extends Achievement {
    measure: string;
}
interface ExtendedAchievementWithPlayer extends ExtendedAchievement {
    player: Player;
}
interface AchievementProgress extends Omit<ExtendedAchievement, 'createdAt'> {
    createdAt: Date | null;
    currentValue: number;
    absoluteProgress: number;
    relativeProgress: number;
}

interface MeasuredDeltaProgress {
    start: number;
    end: number;
    gained: number;
}
interface SkillDelta {
    metric: Skill;
    ehp: MeasuredDeltaProgress;
    rank: MeasuredDeltaProgress;
    level: MeasuredDeltaProgress;
    experience: MeasuredDeltaProgress;
}
interface BossDelta {
    metric: Boss;
    ehb: MeasuredDeltaProgress;
    rank: MeasuredDeltaProgress;
    kills: MeasuredDeltaProgress;
}
interface ActivityDelta {
    metric: Activity;
    rank: MeasuredDeltaProgress;
    score: MeasuredDeltaProgress;
}
interface ComputedMetricDelta {
    metric: ComputedMetric;
    rank: MeasuredDeltaProgress;
    value: MeasuredDeltaProgress;
}
interface PlayerDeltasMap {
    skills: MapOf<Skill, SkillDelta>;
    bosses: MapOf<Boss, BossDelta>;
    activities: MapOf<Activity, ActivityDelta>;
    computed: MapOf<ComputedMetric, ComputedMetricDelta>;
}
interface DeltaLeaderboardEntry {
    player: Player;
    playerId: number;
    startDate: Date;
    endDate: Date;
    gained: number;
}
interface DeltaGroupLeaderboardEntry {
    player: Player;
    startDate: Date;
    endDate: Date;
    data: {
        start: number;
        end: number;
        gained: number;
    };
}

type SnapshotFragment = Omit<Snapshot, 'id'>;
interface SkillValue {
    metric: Skill;
    rank: number;
    level: number;
    experience: number;
    ehp: number;
}
interface BossValue {
    metric: Boss;
    rank: number;
    kills: number;
    ehb: number;
}
interface ActivityValue {
    metric: Activity;
    rank: number;
    score: number;
}
interface ComputedMetricValue {
    metric: ComputedMetric;
    rank: number;
    value: number;
}
interface MetricLeaders {
    skills: MapOf<Skill, Omit<SkillValue, 'ehp'> & {
        player: Player | null;
    }>;
    bosses: MapOf<Boss, Omit<BossValue, 'ehb'> & {
        player: Player | null;
    }>;
    activities: MapOf<Activity, ActivityValue & {
        player: Player | null;
    }>;
    computed: MapOf<ComputedMetric, ComputedMetricValue & {
        player: Player | null;
    }>;
}
interface FormattedSnapshot {
    id: number;
    playerId: number;
    createdAt: Date;
    importedAt: Date | null;
    data: {
        skills: MapOf<Skill, SkillValue>;
        bosses: MapOf<Boss, BossValue>;
        activities: MapOf<Activity, ActivityValue>;
        computed: MapOf<ComputedMetric, ComputedMetricValue>;
    };
}

interface GroupListItem extends Omit<Group, 'verificationHash'> {
    memberCount: number;
}
interface GroupDetails extends GroupListItem {
    socialLinks: GroupSocialLinks;
    memberships: MembershipWithPlayer[];
    roleOrders: GroupRoleOrder[];
}
interface MembershipWithGroup extends Membership {
    group: GroupListItem;
}
interface MembershipWithPlayer extends Membership {
    player: Player;
}
interface MemberInput {
    username: string;
    role: string | GroupRole;
}
interface GroupHiscoresSkillItem {
    type: 'skill';
    rank: number;
    level: number;
    experience: number;
}
interface GroupHiscoresBossItem {
    type: 'boss';
    rank: number;
    kills: number;
}
interface GroupHiscoresActivityItem {
    type: 'activity';
    rank: number;
    score: number;
}
interface GroupHiscoresComputedMetricItem {
    type: 'computed';
    rank: number;
    value: number;
}
interface GroupHiscoresEntry {
    player: Player;
    data: GroupHiscoresSkillItem | GroupHiscoresBossItem | GroupHiscoresActivityItem | GroupHiscoresComputedMetricItem;
}
interface GroupStatistics {
    maxedCombatCount: number;
    maxedTotalCount: number;
    maxed200msCount: number;
    averageStats: FormattedSnapshot;
    metricLeaders: MetricLeaders;
}
type MemberRoleChangeEvent = Omit<MemberActivity, 'createdAt'>;
type MemberJoinedEvent = Omit<MemberActivity, 'createdAt' | 'previousRole'>;
type MemberLeftEvent = Omit<MemberActivity, 'createdAt' | 'previousRole'>;
type MemberActivityWithPlayer = MemberActivity & {
    player: Player;
};

type CleanCompetition = Omit<Competition, 'verificationHash'>;
type CleanParticipation = Omit<Participation, 'startSnapshotId' | 'endSnapshotId'>;
interface CompetitionListItem extends CleanCompetition {
    group?: GroupListItem;
    participantCount: number;
}
interface CompetitionDetails extends CompetitionListItem {
    participations: ParticipationWithPlayerAndProgress[];
}
interface CompetitionWithParticipations extends CompetitionListItem {
    participations: ParticipationWithPlayer[];
}
interface ParticipationWithCompetition extends CleanParticipation {
    competition: CompetitionListItem;
}
interface ParticipationWithPlayer extends CleanParticipation {
    player: Player;
}
interface ParticipationWithPlayerAndProgress extends ParticipationWithPlayer {
    progress: MeasuredDeltaProgress;
    levels: MeasuredDeltaProgress;
}
interface ParticipationWithCompetitionAndStandings extends ParticipationWithCompetition {
    progress: MeasuredDeltaProgress;
    levels: MeasuredDeltaProgress;
    rank: number;
}
interface Team {
    name: string;
    participants: string[];
}
type Top5ProgressResult = Array<{
    player: Player;
    history: Array<{
        value: number;
        date: Date;
    }>;
}>;

declare enum EfficiencyAlgorithmType {
    MAIN = "main",
    IRONMAN = "ironman",
    ULTIMATE = "ultimate",
    LVL3 = "lvl3",
    F2P = "f2p",
    F2P_LVL3 = "f2p_lvl3",
    F2P_IRONMAN = "f2p_ironman",
    F2P_LVL3_IRONMAN = "f2p_lvl3_ironman"
}
interface SkillMetaMethod {
    rate: number;
    realRate?: number;
    startExp: number;
    description: string;
}
interface SkillMetaConfig {
    skill: Skill;
    methods: Array<SkillMetaMethod>;
    bonuses: Bonus[];
}
interface BossMetaConfig {
    boss: Boss;
    rate: number;
}
interface Bonus {
    originSkill: Skill;
    bonusSkill: Skill;
    startExp: number;
    endExp: number;
    maxBonus?: number;
    end: boolean;
    ratio: number;
}

type DenyContext = {
    reason: 'manual_review';
} | {
    reason: 'old_stats_cannot_be_found';
} | {
    reason: 'new_name_not_on_the_hiscores';
} | {
    reason: 'negative_gains';
    negativeGains: MapOf<Metric, number>;
};
type SkipContext = {
    reason: 'transition_period_too_long';
    maxHoursDiff: number;
    hoursDiff: number;
} | {
    reason: 'excessive_gains';
    ehpDiff: number;
    ehbDiff: number;
    hoursDiff: number;
} | {
    reason: 'total_level_too_low';
    minTotalLevel: number;
    totalLevel: number;
};
type NameChangeDetails = {
    nameChange: NameChange;
    data?: {
        isNewOnHiscores: boolean;
        isOldOnHiscores: boolean;
        isNewTracked: boolean;
        hasNegativeGains: boolean;
        negativeGains: MapOf<Metric, number> | null;
        timeDiff: number;
        hoursDiff: number;
        ehpDiff: number;
        ehbDiff: number;
        oldStats: FormattedSnapshot;
        newStats: FormattedSnapshot | null;
    };
};
type NameChangeWithPlayer = NameChange & {
    player: Player;
};

interface PlayerDetails extends Player {
    combatLevel: number;
    archive: PlayerArchive | null;
    latestSnapshot: FormattedSnapshot | null;
}
interface FlaggedPlayerReviewContext {
    previous: FormattedSnapshot;
    rejected: FormattedSnapshot;
    negativeGains: boolean;
    excessiveGains: boolean;
    possibleRollback: boolean;
    excessiveGainsReversed: boolean;
    data: {
        stackableGainedRatio: number;
        previousEHP: number;
        previousEHB: number;
        previousRank: number;
        rejectedEHP: number;
        rejectedEHB: number;
        rejectedRank: number;
    };
}
type PlayerArchiveWithPlayer = PlayerArchive & {
    player: Player;
};

type RecordLeaderboardEntry = Record & {
    player: Player;
};

type MapOf<K extends keyof any, T> = {
    [P in K]: T;
};

declare enum CompetitionStatus {
    UPCOMING = "upcoming",
    ONGOING = "ongoing",
    FINISHED = "finished"
}
declare enum CompetitionCSVTableType {
    TEAM = "team",
    TEAMS = "teams",
    PARTICIPANTS = "participants"
}
declare const CompetitionTypeProps: MapOf<CompetitionType, {
    name: string;
}>;
declare const CompetitionStatusProps: MapOf<CompetitionStatus, {
    name: string;
}>;
declare const COMPETITION_TYPES: ("classic" | "team")[];
declare const COMPETITION_STATUSES: CompetitionStatus[];
declare function isCompetitionType(typeString: string): typeString is CompetitionType;
declare function isCompetitionStatus(statusString: string): statusString is CompetitionStatus;

interface CountryDetails {
    code: Country;
    name: string;
}
declare const CountryProps: MapOf<Country, CountryDetails>;
declare const COUNTRY_CODES: ("AD" | "AE" | "AF" | "AG" | "AI" | "AL" | "AM" | "AO" | "AQ" | "AR" | "AS" | "AT" | "AU" | "AW" | "AX" | "AZ" | "BA" | "BB" | "BD" | "BE" | "BF" | "BG" | "BH" | "BI" | "BJ" | "BL" | "BM" | "BN" | "BO" | "BQ" | "BR" | "BS" | "BT" | "BV" | "BW" | "BY" | "BZ" | "CA" | "CC" | "CD" | "CF" | "CG" | "CH" | "CI" | "CK" | "CL" | "CM" | "CN" | "CO" | "CR" | "CU" | "CV" | "CW" | "CX" | "CY" | "CZ" | "DE" | "DJ" | "DK" | "DM" | "DO" | "DZ" | "EC" | "EE" | "EG" | "EH" | "ER" | "ES" | "ET" | "FI" | "FJ" | "FK" | "FM" | "FO" | "FR" | "GA" | "GB" | "GB_NIR" | "GB_SCT" | "GB_WLS" | "GD" | "GE" | "GF" | "GG" | "GH" | "GI" | "GL" | "GM" | "GN" | "GP" | "GQ" | "GR" | "GS" | "GT" | "GU" | "GW" | "GY" | "HK" | "HM" | "HN" | "HR" | "HT" | "HU" | "ID" | "IE" | "IL" | "IM" | "IN" | "IO" | "IQ" | "IR" | "IS" | "IT" | "JE" | "JM" | "JO" | "JP" | "KE" | "KG" | "KH" | "KI" | "KM" | "KN" | "KP" | "KR" | "KW" | "KY" | "KZ" | "LA" | "LB" | "LC" | "LI" | "LK" | "LR" | "LS" | "LT" | "LU" | "LV" | "LY" | "MA" | "MC" | "MD" | "ME" | "MF" | "MG" | "MH" | "MK" | "ML" | "MM" | "MN" | "MO" | "MP" | "MQ" | "MR" | "MS" | "MT" | "MU" | "MV" | "MW" | "MX" | "MY" | "MZ" | "NA" | "NC" | "NE" | "NF" | "NG" | "NI" | "NL" | "NO" | "NP" | "NR" | "NU" | "NZ" | "OM" | "PA" | "PE" | "PF" | "PG" | "PH" | "PK" | "PL" | "PM" | "PN" | "PR" | "PS" | "PT" | "PW" | "PY" | "QA" | "RE" | "RO" | "RS" | "RU" | "RW" | "SA" | "SB" | "SC" | "SD" | "SE" | "SG" | "SH" | "SI" | "SJ" | "SK" | "SL" | "SM" | "SN" | "SO" | "SR" | "SS" | "ST" | "SV" | "SX" | "SY" | "SZ" | "TC" | "TD" | "TF" | "TG" | "TH" | "TJ" | "TK" | "TL" | "TM" | "TN" | "TO" | "TR" | "TT" | "TV" | "TW" | "TZ" | "UA" | "UG" | "UM" | "US" | "UY" | "UZ" | "VA" | "VC" | "VE" | "VG" | "VI" | "VN" | "VU" | "WF" | "WS" | "YE" | "YT" | "ZA" | "ZM" | "ZW")[];
declare function isCountry(countryCodeString: string): countryCodeString is Country;
declare function findCountry(countryIdentifier: string): CountryDetails | undefined;
declare function findCountryByName(countryName: string): CountryDetails | undefined;
declare function findCountryByCode(countryCode: string): CountryDetails | undefined;

declare const MAX_LEVEL = 99;
declare const MAX_VIRTUAL_LEVEL = 126;
declare const MAX_SKILL_EXP = 200000000;
declare const SKILL_EXP_AT_99 = 13034431;
declare const CAPPED_MAX_TOTAL_XP: number;
declare function getExpForLevel(level: number): number;
declare function getLevel(exp: number, virtual?: boolean): number;
declare function getCombatLevel(attack: number, strength: number, defence: number, ranged: number, magic: number, hitpoints: number, prayer: number): number;

declare const GROUP_ROLES: ("magic" | "slayer" | "hunter" | "achiever" | "adamant" | "adept" | "administrator" | "admiral" | "adventurer" | "air" | "anchor" | "apothecary" | "archer" | "armadylean" | "artillery" | "artisan" | "asgarnian" | "assassin" | "assistant" | "astral" | "athlete" | "attacker" | "bandit" | "bandosian" | "barbarian" | "battlemage" | "beast" | "berserker" | "blisterwood" | "blood" | "blue" | "bob" | "body" | "brassican" | "brawler" | "brigadier" | "brigand" | "bronze" | "bruiser" | "bulwark" | "burglar" | "burnt" | "cadet" | "captain" | "carry" | "champion" | "chaos" | "cleric" | "collector" | "colonel" | "commander" | "competitor" | "completionist" | "constructor" | "cook" | "coordinator" | "corporal" | "cosmic" | "councillor" | "crafter" | "crew" | "crusader" | "cutpurse" | "death" | "defender" | "defiler" | "deputy_owner" | "destroyer" | "diamond" | "diseased" | "doctor" | "dogsbody" | "dragon" | "dragonstone" | "druid" | "duellist" | "earth" | "elite" | "emerald" | "enforcer" | "epic" | "executive" | "expert" | "explorer" | "farmer" | "feeder" | "fighter" | "fire" | "firemaker" | "firestarter" | "fisher" | "fletcher" | "forager" | "fremennik" | "gamer" | "gatherer" | "general" | "gnome_child" | "gnome_elder" | "goblin" | "gold" | "goon" | "green" | "grey" | "guardian" | "guthixian" | "harpoon" | "healer" | "hellcat" | "helper" | "herbologist" | "hero" | "holy" | "hoarder" | "ignitor" | "illusionist" | "imp" | "infantry" | "inquisitor" | "iron" | "jade" | "justiciar" | "kandarin" | "karamjan" | "kharidian" | "kitten" | "knight" | "labourer" | "law" | "leader" | "learner" | "legacy" | "legend" | "legionnaire" | "lieutenant" | "looter" | "lumberjack" | "magician" | "major" | "maple" | "marshal" | "master" | "maxed" | "mediator" | "medic" | "mentor" | "member" | "merchant" | "mind" | "miner" | "minion" | "misthalinian" | "mithril" | "moderator" | "monarch" | "morytanian" | "mystic" | "myth" | "natural" | "nature" | "necromancer" | "ninja" | "noble" | "novice" | "nurse" | "oak" | "officer" | "onyx" | "opal" | "oracle" | "orange" | "owner" | "page" | "paladin" | "pawn" | "pilgrim" | "pine" | "pink" | "prefect" | "priest" | "private" | "prodigy" | "proselyte" | "prospector" | "protector" | "pure" | "purple" | "pyromancer" | "quester" | "racer" | "raider" | "ranger" | "record_chaser" | "recruit" | "recruiter" | "red_topaz" | "red" | "rogue" | "ruby" | "rune" | "runecrafter" | "sage" | "sapphire" | "saradominist" | "saviour" | "scavenger" | "scholar" | "scourge" | "scout" | "scribe" | "seer" | "senator" | "sentry" | "serenist" | "sergeant" | "shaman" | "sheriff" | "short_green_guy" | "skiller" | "skulled" | "smiter" | "smith" | "smuggler" | "sniper" | "soul" | "specialist" | "speed_runner" | "spellcaster" | "squire" | "staff" | "steel" | "strider" | "striker" | "summoner" | "superior" | "supervisor" | "teacher" | "templar" | "therapist" | "thief" | "tirannian" | "trialist" | "trickster" | "tzkal" | "tztok" | "unholy" | "vagrant" | "vanguard" | "walker" | "wanderer" | "warden" | "warlock" | "warrior" | "water" | "wild" | "willow" | "wily" | "wintumber" | "witch" | "wizard" | "worker" | "wrath" | "xerician" | "yellow" | "yew" | "zamorakian" | "zarosian" | "zealot" | "zenyte")[];
declare const PRIVELEGED_GROUP_ROLES: GroupRole[];
type GroupRolePropsMap = MapOf<GroupRole, {
    name: string;
    isPriveleged: boolean;
}>;
declare const GroupRoleProps: GroupRolePropsMap;
declare function findGroupRole(roleName: string): GroupRole | null;
declare function isGroupRole(roleString: string): roleString is GroupRole;

declare enum MetricType {
    SKILL = "skill",
    BOSS = "boss",
    ACTIVITY = "activity",
    COMPUTED = "computed"
}
declare enum MetricMeasure {
    EXPERIENCE = "experience",
    KILLS = "kills",
    SCORE = "score",
    VALUE = "value"
}
interface SkillProperties {
    name: string;
    isCombat: boolean;
    isMembers: boolean;
    type: MetricType;
    measure: MetricMeasure;
}
interface BossProperties {
    name: string;
    minimumValue: number;
    isMembers: boolean;
    type: MetricType;
    measure: MetricMeasure;
}
interface ActivityProperties {
    name: string;
    minimumValue: number;
    type: MetricType;
    measure: MetricMeasure;
}
interface ComputedMetricProperties {
    name: string;
    type: MetricType;
    measure: MetricMeasure;
}
declare const MetricProps: {
    readonly ehp: ComputedMetricProperties;
    readonly ehb: ComputedMetricProperties;
    readonly league_points: ActivityProperties;
    readonly bounty_hunter_hunter: ActivityProperties;
    readonly bounty_hunter_rogue: ActivityProperties;
    readonly clue_scrolls_all: ActivityProperties;
    readonly clue_scrolls_beginner: ActivityProperties;
    readonly clue_scrolls_easy: ActivityProperties;
    readonly clue_scrolls_medium: ActivityProperties;
    readonly clue_scrolls_hard: ActivityProperties;
    readonly clue_scrolls_elite: ActivityProperties;
    readonly clue_scrolls_master: ActivityProperties;
    readonly last_man_standing: ActivityProperties;
    readonly pvp_arena: ActivityProperties;
    readonly soul_wars_zeal: ActivityProperties;
    readonly guardians_of_the_rift: ActivityProperties;
    readonly colosseum_glory: ActivityProperties;
    readonly abyssal_sire: BossProperties;
    readonly alchemical_hydra: BossProperties;
    readonly amoxliatl: BossProperties;
    readonly araxxor: BossProperties;
    readonly artio: BossProperties;
    readonly barrows_chests: BossProperties;
    readonly bryophyta: BossProperties;
    readonly callisto: BossProperties;
    readonly calvarion: BossProperties;
    readonly cerberus: BossProperties;
    readonly chambers_of_xeric: BossProperties;
    readonly chambers_of_xeric_challenge_mode: BossProperties;
    readonly chaos_elemental: BossProperties;
    readonly chaos_fanatic: BossProperties;
    readonly commander_zilyana: BossProperties;
    readonly corporeal_beast: BossProperties;
    readonly crazy_archaeologist: BossProperties;
    readonly dagannoth_prime: BossProperties;
    readonly dagannoth_rex: BossProperties;
    readonly dagannoth_supreme: BossProperties;
    readonly deranged_archaeologist: BossProperties;
    readonly duke_sucellus: BossProperties;
    readonly general_graardor: BossProperties;
    readonly giant_mole: BossProperties;
    readonly grotesque_guardians: BossProperties;
    readonly hespori: BossProperties;
    readonly kalphite_queen: BossProperties;
    readonly king_black_dragon: BossProperties;
    readonly kraken: BossProperties;
    readonly kreearra: BossProperties;
    readonly kril_tsutsaroth: BossProperties;
    readonly lunar_chests: BossProperties;
    readonly mimic: BossProperties;
    readonly nex: BossProperties;
    readonly nightmare: BossProperties;
    readonly phosanis_nightmare: BossProperties;
    readonly obor: BossProperties;
    readonly phantom_muspah: BossProperties;
    readonly sarachnis: BossProperties;
    readonly scorpia: BossProperties;
    readonly scurrius: BossProperties;
    readonly skotizo: BossProperties;
    readonly sol_heredit: BossProperties;
    readonly spindel: BossProperties;
    readonly tempoross: BossProperties;
    readonly the_gauntlet: BossProperties;
    readonly the_corrupted_gauntlet: BossProperties;
    readonly the_hueycoatl: BossProperties;
    readonly the_leviathan: BossProperties;
    readonly the_whisperer: BossProperties;
    readonly theatre_of_blood: BossProperties;
    readonly theatre_of_blood_hard_mode: BossProperties;
    readonly thermonuclear_smoke_devil: BossProperties;
    readonly tombs_of_amascut: BossProperties;
    readonly tombs_of_amascut_expert: BossProperties;
    readonly tzkal_zuk: BossProperties;
    readonly tztok_jad: BossProperties;
    readonly vardorvis: BossProperties;
    readonly venenatis: BossProperties;
    readonly vetion: BossProperties;
    readonly vorkath: BossProperties;
    readonly wintertodt: BossProperties;
    readonly zalcano: BossProperties;
    readonly zulrah: BossProperties;
    readonly overall: SkillProperties;
    readonly attack: SkillProperties;
    readonly defence: SkillProperties;
    readonly strength: SkillProperties;
    readonly hitpoints: SkillProperties;
    readonly ranged: SkillProperties;
    readonly prayer: SkillProperties;
    readonly magic: SkillProperties;
    readonly cooking: SkillProperties;
    readonly woodcutting: SkillProperties;
    readonly fletching: SkillProperties;
    readonly fishing: SkillProperties;
    readonly firemaking: SkillProperties;
    readonly crafting: SkillProperties;
    readonly smithing: SkillProperties;
    readonly mining: SkillProperties;
    readonly herblore: SkillProperties;
    readonly agility: SkillProperties;
    readonly thieving: SkillProperties;
    readonly slayer: SkillProperties;
    readonly farming: SkillProperties;
    readonly runecrafting: SkillProperties;
    readonly hunter: SkillProperties;
    readonly construction: SkillProperties;
};
declare const METRICS: Metric[];
declare const SKILLS: Skill[];
declare const BOSSES: Boss[];
declare const ACTIVITIES: Activity[];
declare const COMPUTED_METRICS: ComputedMetric[];
declare const REAL_SKILLS: Skill[];
declare const F2P_BOSSES: Boss[];
declare const MEMBER_SKILLS: Skill[];
declare const COMBAT_SKILLS: Skill[];
declare const REAL_METRICS: (Skill | Activity | Boss)[];
declare function findMetric(metricName: string): Metric | null;
declare function isMetric(metric: Metric | string): metric is Metric;
declare function isSkill(metric: Metric | string): metric is Skill;
declare function isActivity(metric: Metric | string): metric is Activity;
declare function isBoss(metric: Metric | string): metric is Boss;
declare function isComputedMetric(metric: Metric | string): metric is ComputedMetric;
declare function getMetricRankKey<T extends Metric>(metric: T): `${T}Rank`;
type MetricValueKey = `${Skill}Experience` | `${Boss}Kills` | `${Activity}Score` | `${ComputedMetric}Value`;
declare function getMetricValueKey(metric: Metric): MetricValueKey;
declare function getMetricMeasure(metric: Metric): MetricMeasure;
declare function getMetricName(metric: Metric): string;
declare function getMinimumValue(metric: Metric): number;
declare function getParentEfficiencyMetric(metric: Metric): "ehp" | "ehb";

type PeriodPropsMap = MapOf<Period, {
    name: string;
    milliseconds: number;
}>;
declare const PeriodProps: PeriodPropsMap;
declare const PERIODS: ("five_min" | "day" | "week" | "month" | "year")[];
declare function findPeriod(periodName: string): Period | null;
declare function isPeriod(periodString: string): periodString is Period;
declare function parsePeriodExpression(periodExpression: string): {
    expression: string;
    durationMs: number;
};

declare const PlayerTypeProps: MapOf<PlayerType, {
    name: string;
}>;
declare const PlayerBuildProps: MapOf<PlayerBuild, {
    name: string;
}>;
declare const PlayerStatusProps: MapOf<PlayerStatus, {
    name: string;
}>;
declare const PLAYER_TYPES: ("unknown" | "regular" | "ironman" | "hardcore" | "ultimate")[];
declare const PLAYER_BUILDS: ("main" | "f2p" | "f2p_lvl3" | "lvl3" | "zerker" | "def1" | "hp10")[];
declare const PLAYER_STATUSES: ("active" | "unranked" | "flagged" | "archived" | "banned")[];
declare function isPlayerType(typeString: string): typeString is PlayerType;
declare function isPlayerBuild(buildString: string): buildString is PlayerBuild;
declare function isPlayerStatus(statusString: string): statusString is PlayerStatus;
declare function findPlayerType(typeName: string): PlayerType | null;
declare function findPlayerBuild(buildName: string): PlayerBuild | null;

declare function formatNumber(num: number, withLetters?: boolean, decimalPrecision?: number): string | -1;
declare function padNumber(value: number): string;
declare function round(num: number, cases: number): number;

interface GenericCountMessageResponse {
    count: number;
    message: string;
}
interface GenericMessageResponse {
    message: string;
}
type TimeRangeFilter = {
    period: Period | string;
} | {
    startDate: Date;
    endDate: Date;
};
interface BasePlayerFilter {
    country?: Country;
    playerType?: PlayerType;
    playerBuild?: PlayerBuild;
}
/**
 * Groups Client Types
 */
interface GroupMemberFragment {
    username: string;
    role?: GroupRole;
}
interface CreateGroupPayload {
    name: string;
    clanChat?: string;
    homeworld?: number;
    description?: string;
    members: Array<GroupMemberFragment>;
}
type EditGroupPayload = Partial<CreateGroupPayload> & {
    bannerImage?: string;
    profileImage?: string;
    socialLinks?: Partial<GroupSocialLinks>;
    roleOrders?: Array<GroupRoleOrder>;
};
interface CreateGroupResponse {
    group: GroupDetails;
    verificationCode: string;
}
type ChangeMemberRolePayload = Required<GroupMemberFragment>;
type GetGroupGainsFilter = {
    metric: Metric;
} & TimeRangeFilter;
interface GroupRecordsFilter {
    metric: Metric;
    period: Period;
}
/**
 * Competitions Client Types
 */
interface CompetitionsSearchFilter {
    title?: string;
    metric?: Metric;
    type?: CompetitionType;
    status?: CompetitionStatus;
}
type CompetitionDetailsCSVParams = {
    previewMetric?: Metric;
    teamName?: string;
    table?: CompetitionCSVTableType;
};
type CreateCompetitionPayload = {
    title: string;
    metric: Metric;
    startsAt: Date;
    endsAt: Date;
    groupId?: number;
    groupVerificationCode?: string;
} & ({
    participants: string[];
} | {
    teams: Team[];
});
type EditCompetitionPayload = {
    title?: string;
    metric?: Metric;
    startsAt?: Date;
    endsAt?: Date;
    participants?: string[];
    teams?: Team[];
};
type CreateCompetitionResponse = {
    competition: CompetitionWithParticipations;
    verificationCode: string;
};
/**
 * Name Changes Client Types
 */
type NameChangesSearchFilter = {
    username?: string;
    status?: NameChangeStatus;
};
/**
 * Record Client Types
 */
interface RecordLeaderboardFilter extends BasePlayerFilter {
    metric: Metric;
    period: Period;
}
/**
 * Player Client Types
 */
interface PlayerCompetitionsFilter {
    status?: CompetitionStatus;
}
interface PlayerCompetitionStandingsFilter {
    status: Exclude<CompetitionStatus, CompetitionStatus.UPCOMING>;
}
interface PlayerRecordsFilter {
    period: Period | string;
    metric: Metric;
}
interface AssertPlayerTypeResponse {
    player: Player;
    changed: boolean;
}
interface GetPlayerGainsResponse {
    startsAt: Date;
    endsAt: Date;
    data: PlayerDeltasMap;
}
/**
 * Efficiency Client Types
 */
type EfficiencyAlgorithmTypeUnion = `${EfficiencyAlgorithmType}`;
interface EfficiencyLeaderboardsFilter extends BasePlayerFilter {
    metric: typeof Metric.EHP | typeof Metric.EHB | 'ehp+ehb';
}
/**
 * Delta Client Types
 */
interface DeltaLeaderboardFilter extends BasePlayerFilter {
    metric: Metric;
    period: Period | string;
}

declare class BaseAPIClient {
    private headers;
    private baseUrl;
    constructor(headers: object, baseUrl: string);
    private buildParams;
    private fetch;
    private request;
    private requestText;
    postRequest<T>(path: string, body?: unknown): Promise<T>;
    putRequest<T>(path: string, body?: unknown): Promise<T>;
    deleteRequest<T>(path: string, body?: unknown): Promise<T>;
    getRequest<T>(path: string, params?: unknown): Promise<T>;
    getText(path: string, params?: unknown): Promise<string>;
}

declare class DeltasClient extends BaseAPIClient {
    /**
     * Fetches the current top leaderboard for a specific metric, period, playerType, playerBuild and country.
     * @returns A list of deltas, with their respective players, values and dates included.
     */
    getDeltaLeaderboard(filter: DeltaLeaderboardFilter): Promise<DeltaLeaderboardEntry[]>;
}

interface PaginationOptions {
    limit?: number;
    offset?: number;
}

declare class GroupsClient extends BaseAPIClient {
    /**
     * Searches for groups that match a partial name.
     * @returns A list of groups.
     */
    searchGroups(name: string, pagination?: PaginationOptions): Promise<GroupListItem[]>;
    /**
     * Fetches a group's details, including a list of membership objects.
     * @returns A group details object.
     */
    getGroupDetails(id: number): Promise<GroupDetails>;
    /**
     * Creates a new group.
     * @returns The newly created group, and the verification code that authorizes future changes to it.
     */
    createGroup(payload: CreateGroupPayload): Promise<CreateGroupResponse>;
    /**
     * Edits an existing group.
     * @returns The updated group.
     */
    editGroup(id: number, payload: EditGroupPayload, verificationCode: string): Promise<GroupDetails>;
    /**
     * Deletes an existing group.
     * @returns A confirmation message.
     */
    deleteGroup(id: number, verificationCode: string): Promise<GenericMessageResponse>;
    /**
     * Adds all (valid) given usernames (and roles) to a group, ignoring duplicates.
     * @returns The number of members added and a confirmation message.
     */
    addMembers(id: number, members: GroupMemberFragment[], verificationCode: string): Promise<GenericCountMessageResponse>;
    /**
     * Remove all given usernames from a group, ignoring usernames that aren't members.
     * @returns The number of members removed and a confirmation message.
     */
    removeMembers(id: number, usernames: string[], verificationCode: string): Promise<GenericCountMessageResponse>;
    /**
     * Changes a player's role in a given group.
     * @returns The updated membership, with player included.
     */
    changeRole(id: number, payload: ChangeMemberRolePayload, verificationCode: string): Promise<MembershipWithPlayer>;
    /**
     * Adds an "update" request to the queue, for each outdated group member.
     * @returns The number of players to be updated and a confirmation message.
     */
    updateAll(id: number, verificationCode: string): Promise<GenericCountMessageResponse>;
    /**
     * Fetches all of the groups's competitions
     * @returns A list of competitions.
     */
    getGroupCompetitions(id: number, pagination?: PaginationOptions): Promise<CompetitionListItem[]>;
    getGroupGains(id: number, filter: GetGroupGainsFilter, pagination?: PaginationOptions): Promise<DeltaGroupLeaderboardEntry[]>;
    /**
     * Fetches a group members' latest achievements.
     * @returns A list of achievements.
     */
    getGroupAchievements(id: number, pagination?: PaginationOptions): Promise<ExtendedAchievementWithPlayer[]>;
    /**
     * Fetches a group's record leaderboard for a specific metric and period.
     * @returns A list of records, including their respective players.
     */
    getGroupRecords(id: number, filter: GroupRecordsFilter, pagination?: PaginationOptions): Promise<RecordLeaderboardEntry[]>;
    /**
     * Fetches a group's hiscores for a specific metric.
     * @returns A list of hiscores entries (value, rank), including their respective players.
     */
    getGroupHiscores(id: number, metric: Metric, pagination?: PaginationOptions): Promise<GroupHiscoresEntry[]>;
    /**
     * Fetches a group members' latest name changes.
     * @returns A list of name change (approved) requests.
     */
    getGroupNameChanges(id: number, pagination?: PaginationOptions): Promise<NameChangeWithPlayer[]>;
    /**
     * Fetches a group's general statistics.
     * @returns An object with a few statistic values and an average stats snapshot.
     */
    getGroupStatistics(id: number): Promise<GroupStatistics>;
    /**
     * Fetches a group's activity.
     * @returns A list of a group's (join, leave and role changed) activity.
     */
    getGroupActivity(id: number, pagination?: PaginationOptions): Promise<MemberActivityWithPlayer[]>;
    /**
     * Fetches the groups's member list in CSV format.
     * @returns A string containing the CSV content.
     */
    getMembersCSV(id: number): Promise<string>;
}

declare class PlayersClient extends BaseAPIClient {
    /**
     * Searches players by partial username.
     * @returns A list of players.
     */
    searchPlayers(partialUsername: string, pagination?: PaginationOptions): Promise<Player[]>;
    /**
     * Updates/tracks a player.
     * @returns The player's new details, including the latest snapshot.
     */
    updatePlayer(username: string): Promise<PlayerDetails>;
    /**
     * Asserts (and attempts to fix, if necessary) a player's game-mode type.
     * @returns The updated player, and an indication of whether the type was changed.
     */
    assertPlayerType(username: string): Promise<AssertPlayerTypeResponse>;
    /**
     * Fetches a player's details.
     * @returns The player's details, including the latest snapshot.
     */
    getPlayerDetails(username: string): Promise<PlayerDetails>;
    /**
     * Fetches a player's details by ID.
     * @returns The player's details, including the latest snapshot.
     */
    getPlayerDetailsById(id: number): Promise<PlayerDetails>;
    /**
     * Fetches a player's current achievements.
     * @returns A list of achievements.
     */
    getPlayerAchievements(username: string): Promise<ExtendedAchievement[]>;
    /**
     * Fetches a player's current achievement progress.
     * @returns A list of achievements (completed or otherwise), with their respective relative/absolute progress percentage.
     */
    getPlayerAchievementProgress(username: string): Promise<AchievementProgress[]>;
    /**
     * Fetches all of the player's competition participations.
     * @returns A list of participations, with the respective competition included.
     */
    getPlayerCompetitions(username: string, filter?: PlayerCompetitionsFilter, pagination?: PaginationOptions): Promise<ParticipationWithCompetition[]>;
    /**
     * Fetches all of the player's competition participations' standings.
     * @returns A list of participations, with the respective competition, rank and progress included.
     */
    getPlayerCompetitionStandings(username: string, filter: PlayerCompetitionsFilter): Promise<ParticipationWithCompetitionAndStandings[]>;
    /**
     * Fetches all of the player's group memberships.
     * @returns A list of memberships, with the respective group included.
     */
    getPlayerGroups(username: string, pagination?: PaginationOptions): Promise<MembershipWithGroup[]>;
    /**
     * Fetches a player's gains, for a specific period or time range, as a [metric: data] map.
     * @returns A map of each metric's gained data.
     */
    getPlayerGains(username: string, options: TimeRangeFilter): Promise<GetPlayerGainsResponse>;
    /**
     * Fetches all of the player's records.
     * @returns A list of records.
     */
    getPlayerRecords(username: string, options?: PlayerRecordsFilter): Promise<Record[]>;
    /**
     * Fetches all of the player's past snapshots.
     * @returns A list of snapshots.
     */
    getPlayerSnapshots(username: string, filter: TimeRangeFilter, pagination?: PaginationOptions): Promise<FormattedSnapshot[]>;
    /**
     * Fetches all of the player's past snapshots' timeline.
     * @returns A list of timeseries data (value, rank, date)
     */
    getPlayerSnapshotTimeline(username: string, metric: Metric, options?: TimeRangeFilter): Promise<{
        value: number;
        rank: number;
        date: Date;
    }[]>;
    /**
     * Fetches all of the player's approved name changes.
     * @returns A list of name changes.
     */
    getPlayerNames(username: string): Promise<NameChange[]>;
    /**
     * Fetches all of archived players that previously held this username.
     * @returns A list of player archives.
     */
    getPlayerArchives(username: string): Promise<PlayerArchiveWithPlayer[]>;
}

declare class RecordsClient extends BaseAPIClient {
    /**
     * Fetches the current records leaderboard for a specific metric, period, playerType, playerBuild and country.
     * @returns A list of records, with their respective players, dates and values included.
     */
    getRecordLeaderboard(filter: RecordLeaderboardFilter): Promise<RecordLeaderboardEntry[]>;
}

declare class EfficiencyClient extends BaseAPIClient {
    /**
     * Fetches the current efficiency leaderboard for a specific efficiency metric, playerType, playerBuild and country.
     * @returns A list of players.
     */
    getEfficiencyLeaderboards(filter: EfficiencyLeaderboardsFilter, pagination?: PaginationOptions): Promise<Player[]>;
    /**
     * Fetches the top EHP (Efficient Hours Played) rates.
     * @returns A list of skilling methods and their bonus exp ratios.
     */
    getEHPRates(algorithmType: EfficiencyAlgorithmTypeUnion): Promise<SkillMetaConfig[]>;
    /**
     * Fetches the top EHB (Efficient Hours Bossed) rates.
     * @returns A list of bosses and their respective "per-hour" kill rates.
     */
    getEHBRates(algorithmType: EfficiencyAlgorithmTypeUnion): Promise<BossMetaConfig[]>;
}

declare class NameChangesClient extends BaseAPIClient {
    /**
     * Searches for name changes that match a name and/or status filter.
     * @returns A list of name changes.
     */
    searchNameChanges(filter: NameChangesSearchFilter, pagination?: PaginationOptions): Promise<NameChange[]>;
    /**
     * Submits a name change request between two usernames (old and new).
     * @returns A pending name change request, to be reviewed and resolved at a later date.
     */
    submitNameChange(oldName: string, newName: string): Promise<NameChange>;
}

declare class CompetitionsClient extends BaseAPIClient {
    /**
     * Searches for competitions that match a title, type, metric and status filter.
     * @returns A list of competitions.
     */
    searchCompetitions(filter: CompetitionsSearchFilter, pagination?: PaginationOptions): Promise<CompetitionListItem[]>;
    /**
     * Fetches the competition's full details, including all the participants and their progress.
     * @returns A competition with a list of participants.
     */
    getCompetitionDetails(id: number, previewMetric?: Metric): Promise<CompetitionDetails>;
    /**
     * Fetches the competition's participant list in CSV format.
     * @returns A string containing the CSV content.
     */
    getCompetitionDetailsCSV(id: number, params?: CompetitionDetailsCSVParams): Promise<string>;
    /**
     * Fetches all the values (exp, kc, etc) in chronological order within the bounds
     * of the competition, for the top 5 participants.
     * @returns A list of competition progress objects, including the player and their value history over time.
     */
    getCompetitionTopHistory(id: number, previewMetric?: Metric): Promise<Top5ProgressResult>;
    /**
     * Creates a new competition.
     * @returns The newly created competition, and the verification code that authorizes future changes to it.
     */
    createCompetition(payload: CreateCompetitionPayload): Promise<CreateCompetitionResponse>;
    /**
     * Edits an existing competition.
     * @returns The updated competition.
     */
    editCompetition(id: number, payload: EditCompetitionPayload, verificationCode: string): Promise<CompetitionWithParticipations>;
    /**
     * Deletes an existing competition.
     * @returns A confirmation message.
     */
    deleteCompetition(id: number, verificationCode: string): Promise<GenericMessageResponse>;
    /**
     * Adds all (valid) given participants to a competition, ignoring duplicates.
     * @returns The number of participants added and a confirmation message.
     */
    addParticipants(id: number, participants: string[], verificationCode: string): Promise<GenericCountMessageResponse>;
    /**
     * Remove all given usernames from a competition, ignoring usernames that aren't competing.
     * @returns The number of participants removed and a confirmation message.
     */
    removeParticipants(id: number, participants: string[], verificationCode: string): Promise<GenericCountMessageResponse>;
    /**
     * Adds all (valid) given teams to a team competition, ignoring duplicates.
     * @returns The number of participants added and a confirmation message.
     */
    addTeams(id: number, teams: Team[], verificationCode: string): Promise<GenericCountMessageResponse>;
    /**
     * Remove all given team names from a competition, ignoring names that don't exist.
     * @returns The number of participants removed and a confirmation message.
     */
    removeTeams(id: number, teamNames: string[], verificationCode: string): Promise<GenericCountMessageResponse>;
    /**
     * Adds an "update" request to the queue, for each outdated competition participant.
     * @returns The number of players to be updated and a confirmation message.
     */
    updateAll(id: number, verificationCode: string): Promise<GenericCountMessageResponse>;
}

interface WOMClientOptions {
    apiKey?: string;
    userAgent?: string;
    baseAPIUrl?: string;
}
declare class WOMClient extends BaseAPIClient {
    deltas: DeltasClient;
    groups: GroupsClient;
    players: PlayersClient;
    records: RecordsClient;
    efficiency: EfficiencyClient;
    nameChanges: NameChangesClient;
    competitions: CompetitionsClient;
    constructor(options?: WOMClientOptions);
}

export { ACTIVITIES, type Achievement, type AchievementDefinition, type AchievementProgress, type AchievementTemplate, Activity, type ActivityDelta, ActivityType, type ActivityValue, type AssertPlayerTypeResponse, BOSSES, type Bonus, Boss, type BossDelta, type BossMetaConfig, type BossValue, CAPPED_MAX_TOTAL_XP, COMBAT_SKILLS, COMPETITION_STATUSES, COMPETITION_TYPES, COMPUTED_METRICS, COUNTRY_CODES, type ChangeMemberRolePayload, CompetitionCSVTableType, type CompetitionDetails, type CompetitionDetailsCSVParams, type CompetitionListItem, CompetitionStatus, CompetitionStatusProps, CompetitionType, CompetitionTypeProps, type CompetitionWithParticipations, type CompetitionsSearchFilter, ComputedMetric, type ComputedMetricDelta, type ComputedMetricValue, Country, type CountryDetails, CountryProps, type CreateCompetitionPayload, type CreateCompetitionResponse, type CreateGroupPayload, type CreateGroupResponse, type DeltaGroupLeaderboardEntry, type DeltaLeaderboardEntry, type DeltaLeaderboardFilter, type DenyContext, type EditCompetitionPayload, type EditGroupPayload, EfficiencyAlgorithmType, type EfficiencyAlgorithmTypeUnion, type EfficiencyLeaderboardsFilter, type ExtendedAchievement, type ExtendedAchievementWithPlayer, F2P_BOSSES, type FlaggedPlayerReviewContext, type FormattedSnapshot, GROUP_ROLES, type GenericCountMessageResponse, type GenericMessageResponse, type GetGroupGainsFilter, type GetPlayerGainsResponse, type Group, type GroupDetails, type GroupHiscoresActivityItem, type GroupHiscoresBossItem, type GroupHiscoresComputedMetricItem, type GroupHiscoresEntry, type GroupHiscoresSkillItem, type GroupListItem, type GroupMemberFragment, type GroupRecordsFilter, GroupRole, GroupRoleProps, type GroupStatistics, MAX_LEVEL, MAX_SKILL_EXP, MAX_VIRTUAL_LEVEL, MEMBER_SKILLS, METRICS, type MapOf, type MeasuredDeltaProgress, type MemberActivityWithPlayer, type MemberInput, type MemberJoinedEvent, type MemberLeftEvent, type MemberRoleChangeEvent, type MembershipWithGroup, type MembershipWithPlayer, Metric, type MetricLeaders, MetricMeasure, MetricProps, MetricType, type MetricValueKey, type NameChange, type NameChangeDetails, NameChangeStatus, type NameChangeWithPlayer, type NameChangesSearchFilter, PERIODS, PLAYER_BUILDS, PLAYER_STATUSES, PLAYER_TYPES, PRIVELEGED_GROUP_ROLES, type ParticipationWithCompetition, type ParticipationWithCompetitionAndStandings, type ParticipationWithPlayer, type ParticipationWithPlayerAndProgress, Period, PeriodProps, type Player, type PlayerArchiveWithPlayer, PlayerBuild, PlayerBuildProps, type PlayerCompetitionStandingsFilter, type PlayerCompetitionsFilter, type PlayerDeltasMap, type PlayerDetails, type PlayerRecordsFilter, PlayerStatus, PlayerStatusProps, PlayerType, PlayerTypeProps, REAL_METRICS, REAL_SKILLS, type Record, type RecordLeaderboardEntry, type RecordLeaderboardFilter, SKILLS, SKILL_EXP_AT_99, Skill, type SkillDelta, type SkillMetaConfig, type SkillMetaMethod, type SkillValue, type SkipContext, type Snapshot, type SnapshotFragment, type Team, type TimeRangeFilter, type Top5ProgressResult, WOMClient, findCountry, findCountryByCode, findCountryByName, findGroupRole, findMetric, findPeriod, findPlayerBuild, findPlayerType, formatNumber, getCombatLevel, getExpForLevel, getLevel, getMetricMeasure, getMetricName, getMetricRankKey, getMetricValueKey, getMinimumValue, getParentEfficiencyMetric, isActivity, isBoss, isCompetitionStatus, isCompetitionType, isComputedMetric, isCountry, isGroupRole, isMetric, isPeriod, isPlayerBuild, isPlayerStatus, isPlayerType, isSkill, padNumber, parsePeriodExpression, round };
